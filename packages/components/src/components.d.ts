/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { SortOrder } from "./enums/sort-order.enum";
import { UnitSystem } from "./enums/unit-system.enum";
import { Location } from "@mapsindoors/typescript-interfaces";
import { LocationBookingDuration } from "./enums/location-booking-duration.enum";
import { IPositionProvider, MapsIndoorsPosition } from "./types/position-provider.interface";
import { NotificationPosition } from "./enums/notification-position.enum";
import { NotificationMessage } from "./types/notification-message.interface";
import { NotificationType } from "./enums/notification-type.enum";
import { Route } from "./types/route.interface";
import { RouteTravelMode } from "./enums/route-travel-mode.enum";
import { DirectionsTranslations } from "./types/directions-translations.interface";
export { SortOrder } from "./enums/sort-order.enum";
export { UnitSystem } from "./enums/unit-system.enum";
export { Location } from "@mapsindoors/typescript-interfaces";
export { LocationBookingDuration } from "./enums/location-booking-duration.enum";
export { IPositionProvider, MapsIndoorsPosition } from "./types/position-provider.interface";
export { NotificationPosition } from "./enums/notification-position.enum";
export { NotificationMessage } from "./types/notification-message.interface";
export { NotificationType } from "./enums/notification-type.enum";
export { Route } from "./types/route.interface";
export { RouteTravelMode } from "./enums/route-travel-mode.enum";
export { DirectionsTranslations } from "./types/directions-translations.interface";
export namespace Components {
    interface ComboBoxItem {
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "excludefromall": boolean;
        /**
          * @default false
         */
        "selected": boolean;
        "text": string;
        "value": string;
    }
    interface MiCard {
    }
    interface MiChip {
        /**
          * Checks if the chip is active and applies different styling to the component.
          * @type {boolean}
          * @default false
         */
        "active": boolean;
        /**
          * The background color of the chip. The default #005655 HEX value refers to the --brand-colors-dark-pine-100 from MIDT
          * @type {string}
          * @default '#005655'
         */
        "backgroundColor"?: string;
        /**
          * The chip content that is displayed in the component.
          * @type {string}
         */
        "content": string;
        /**
          * The icon source.
          * @type {string}
         */
        "icon"?: string;
    }
    interface MiColumn {
        /**
          * The alignContent property sets the alignment of the column's content.
          * @type {('left'|'center'|'right')}
          * @default 'left'
          * @example <mi-column align-content="center"></mi-column>
          * @memberof Column
         */
        "alignContent": string;
        /**
          * The name of the property on the row object which value will be displayed.
          * @type {string}
          * @memberof Column
         */
        "binding": string;
        /**
          * If present, the column width is fitted the content.
          * @type {boolean}
          * @memberof Column
          * @default false
         */
        "fitContent": boolean;
        /**
          * The label that will be shown in the table header.
          * @type {string}
          * @memberof Column
         */
        "label": string;
        /**
          * The monospace property sets the font-family to monospace.
          * @type {boolean}
          * @memberof Column
          * @default false
         */
        "monospace": boolean;
        /**
          * If present, the table will be pre-sorted by this column.
          * @type {('asc'|'desc')}
          * @memberof Column
         */
        "sort": string;
        /**
          * If present, the column will be sortable. *For sorting dates use `sortable="date"`.
          * @type {(''|'date'|'default')}
          * @memberof Column
         */
        "sortable": string;
        /**
          * The width property sets the column's width. All CSS length units are accepted.
          * @example <mi-column width="100px"></mi-column>
          * @type {string}
          * @default 'auto'
          * @memberof Column
         */
        "width": string;
    }
    interface MiComboBox {
        /**
          * Sets the disabled state for the dropdown.
          * @default false
         */
        "disabled": boolean;
        /**
          * This attribute indicates that the items can be filtered using the input field present at the top. If it is not specified, the input field will not be visible, and filtering is not possible.
          * @type {boolean}
          * @default false
         */
        "filterable": boolean;
        /**
          * Gets or sets the list items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @returns 
          * @default []
         */
        "items": Array<HTMLMiDropdownItemElement>;
        /**
          * Sort order of items.
          * @type {SortOrder}
         */
        "itemsOrder": SortOrder;
        /**
          * Guiding message when presented with a content window that has no rows. Default language is English.
          * @default 'No results found'
         */
        "noResultsMessage": string;
        /**
          * Gets or sets the state of the dropdown. If the attribute is set to true then the dropdown will be expanded.
          * @type {boolean}
          * @default false
         */
        "open": boolean;
        /**
          * Gets the selected items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @default []
         */
        "selected": Array<HTMLMiDropdownItemElement>;
    }
    interface MiDataTable {
        /**
          * Guiding message when presented with a table that has no rows.
          * @default 'No results found'
         */
        "emptyPageHeader": string;
        /**
          * Guiding message for actionable steps to be performed in order to render new search results.
         */
        "emptyPageSubheader": string;
        /**
          * Whether or not the table header should be sticky.
          * @default true
         */
        "isHeaderSticky": boolean;
        /**
          * The maximum number of rows to be displayed.
         */
        "maxRows": number;
        /**
          * The page of rows to be displayed. Eg. If the maxRows is set to be less the total number of rows, the page property can specify which chunk of rows to show.
         */
        "page": number;
        /**
          * Array of objects for each row in the table.
          * @default []
         */
        "rows": Array<any>;
        /**
          * The selectable attribute specifies whether the first column in the table should be checkboxes. The header will be a select all or none checkbox.
          * @default false
         */
        "selectable": boolean;
        /**
          * The selected property contains a Set of all selected rows. This property is only relevant if the selectable attribute is present.
          * @default new Set()
         */
        "selected": Set<any>;
    }
    interface MiDistance {
        /**
          * Distance in meters.
          * @type {number}
         */
        "meters": number;
        /**
          * Set imperial or metric as default unit system. Default is Metric unless the browser is running US English. In that case Imperial.
          * @type {UnitSystem}
          * @default navigator.language === 'en-US' ? UnitSystem.Imperial : UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiDropdown {
        /**
          * Clear filter.
         */
        "clearFilter": () => Promise<void>;
        /**
          * Sets the disabled state for the dropdown.
          * @default false
         */
        "disabled": boolean;
        /**
          * Sets the alignment of the dropdown. The default alignment is 'left'.
          * @type {('right' | 'left')}
          * @default 'left'
         */
        "dropdownAlignment": 'right' | 'left';
        /**
          * This attribute indicates that the items can be filtered using the input field present at the top. If it is not specified, the input field will not be visible, and filtering is not possible.
          * @type {boolean}
          * @default false
         */
        "filterable": boolean;
        /**
          * Sets the alternative text for the icon.
         */
        "iconAlt": string;
        /**
          * Sets the icon on the left-hand side of the component.
         */
        "iconSrc": string;
        /**
          * Gets or sets the list items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @default []
         */
        "items": Array<HTMLMiDropdownItemElement>;
        /**
          * Sort order of items.
          * @type {SortOrder}
         */
        "itemsOrder": SortOrder;
        /**
          * The label will be displayed in as the text of the dropdown if the attribute multiple is present. Only required if multiple is present.
          * @type {string}
         */
        "label": string;
        /**
          * This attribute indicates that multiple items can be selected in the list. If it is not specified, then only one item can be selected at a time.
          * @type {boolean}
          * @default false
         */
        "multiple": boolean;
        /**
          * Guiding message when presented with a content window that has no rows. Default language is English.
          * @default 'No results found'
         */
        "noResultsMessage": string;
        /**
          * Gets or sets the state of the dropdown. If the attribute is set to true then the dropdown will be expanded.
          * @type {boolean}
          * @default false
         */
        "open": boolean;
        /**
          * If present, it dictates placeholder for an filterable input field in the dropdown. Defaults to 'Type to filter...'.
          * @type {string}
          * @default 'Type to filter...'
         */
        "placeholder": string;
        /**
          * Gets the selected items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @default []
         */
        "selected": Array<HTMLMiDropdownItemElement>;
    }
    interface MiDropdownItem {
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "excludefromall": boolean;
        /**
          * @default false
         */
        "selected": boolean;
        "text": string;
        "value": string;
    }
    interface MiFloorSelector {
        /**
          * MapsIndoors instance.
         */
        "mapsindoors": any;
        /**
          * The color to use as the primary color (as background color of the selected floor in the list).
          * @type {string}
          * @default '#005655'
         */
        "primaryColor"?: string;
    }
    interface MiIcon {
        /**
          * The icon name. A list of supported icons can be found in the documentation.
          * @type {string}
         */
        "iconName": string;
    }
    interface MiKeyboard {
        /**
          * Clear the input field.
         */
        "clearInputField": () => Promise<void>;
        /**
          * The active input element.
          * @type {HTMLInputElement}
         */
        "inputElement": HTMLInputElement;
        /**
          * The keyboard language to use. Supported values are "en" (English), "fr" (French), "de", (German) and "da" (Danish). If omitted, the browser language will be used. Defaults to English.
         */
        "language": string;
        /**
          * The keyboard layout to use. Defaults to alphabetic.
          * @type {KeyboardLayout}
          * @default KeyboardLayout.Alphabetic
         */
        "layout": string;
    }
    interface MiList {
        /**
          * @description Determines if the MI Scroll Buttons Component should be rendered.
          * @type {boolean}
          * @default false
         */
        "scrollButtonsEnabled": boolean;
        /**
          * @description Determines how far to scroll when clicking one of the buttons from the MI Scroll Buttons Component.
          * @type {number}
          * @default 100
         */
        "scrollLength": number;
    }
    interface MiListItemCategory {
        /**
          * @description Array of Categories.
          * @type {Array<Category>}
         */
        "category": any;
        /**
          * @description List orientation. Accepts the following values: 'vertical' and 'horizontal'.
          * @type {string}
          * @default 'vertical'
         */
        "orientation": string;
    }
    interface MiListItemLocation {
        /**
          * @description Optional URL to icon to render for the Location. If not set, imageURL on the Location data will be used.
          * @type {string}
         */
        "icon": string;
        /**
          * @description Add a badge to the location icon of the type given as value.
          * @type {string}
         */
        "iconBadge": string;
        /**
          * @description The value of the badge.
          * @type {string} For availability, use "true" or "false".
         */
        "iconBadgeValue": string;
        /**
          * @description The word used for "Level" when showing level info. Default is "Level".
          * @default 'Level'
         */
        "level": string;
        /**
          * @description Location object.
         */
        "location": any;
        /**
          * Whether to show the External ID.
          * @default true
         */
        "showExternalId": boolean;
        /**
          * @description Set imperial or metric as unit for distance.
          * @type {UnitSystem}
         */
        "unit": UnitSystem;
    }
    interface MiLocationBooking {
        /**
          * The title of the created bookings. Defaults to "Booked".
          * @type {string}
          * @default 'Booked'
         */
        "bookingTitle": string;
        /**
          * Wether booking should be performed for 30 or 60 minutes.
          * @type {LocationBookingDuration}
          * @default LocationBookingDuration.min30
         */
        "duration": LocationBookingDuration;
        /**
          * MapsIndoors location to book.
          * @type {Location} MapsIndoors location
         */
        "location": Location;
        /**
          * How many time slots to show going forward in time. Default to 4.
          * @default 4
         */
        "show": number;
        /**
          * No bookings will be allowed before this hour. Default value is 8.
          * @type {number} - the hour in 24h format
          * @default 8
         */
        "startHour": number;
        /**
          * No bookings will be allowed within and after this hour. Default value is 18.
          * @type {number} - the hour (0-23)
          * @default 18
         */
        "stopHour": number;
        /**
          * Translations object for translatable strings.
          * @default {         book: 'Book',         cancel: 'Cancel',         booked: 'Booked'     }
         */
        "translations": {
        book: string;
        cancel: string;
        booked: string;
    };
    }
    interface MiLocationInfo {
        /**
          * @description The word used for "Level" when showing level info. Default is "Level".
          * @default 'Level'
         */
        "level": string;
        /**
          * @description Location object.
         */
        "location": any;
        /**
          * @description Whether to show the External ID.
          * @default true
         */
        "showExternalId": boolean;
        /**
          * @description Whether to show the floor information. Default is true.
          * @default true
         */
        "showFloor": boolean;
    }
    interface MiMapGooglemaps {
        /**
          * Clear existing MapsIndoors location highlight.
          * @returns
         */
        "clearHighlightLocation": () => Promise<void>;
        /**
          * Set to true to prevent external links on the map from opening. This can be useful when running the map on a kiosk where you never want the browser to navigate away.
          * @type {boolean}
          * @default false
         */
        "disableExternalLinks": boolean;
        /**
          * Set or get the current floor index shown on the map.
          * @type {string}
         */
        "floorIndex": string;
        /**
          * Render the floor selector as a Map Control at the given position.
          * @type {string}
         */
        "floorSelectorControlPosition": string;
        /**
          * Get the MapsIndoors Directions Renderer Instance.
          * @returns
         */
        "getDirectionsRendererInstance": () => Promise<any>;
        /**
          * Get the MapsIndoors Directions Service Instance.
          * @returns
         */
        "getDirectionsServiceInstance": () => Promise<any>;
        /**
          * Get the map instance.
          * @returns
         */
        "getMapInstance": () => Promise<any>;
        /**
          * Get the MapsIndoors instance.
          * @returns
         */
        "getMapsIndoorsInstance": () => Promise<any>;
        /**
          * The Google Maps API key.
          * @type {string}
          * @default ''
         */
        "gmApiKey": string;
        /**
          * Google Maps options. Defaults to zoom: 17, maxZoom: 21, center: { lat: 0, lng: 0 }, mapTypeControl: false, streetViewControl: false. https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
          * @type {google.maps.MapOptions}
          * @default {         zoom: 17,         maxZoom: 21,         center: { lat: 0, lng: 0 },         mapTypeControl: false,         streetViewControl: false     }
         */
        "gmOptions": google.maps.MapOptions;
        /**
          * Highlight a MapsIndoors location. Only a single location can be highlighted at the time.
          * @param location
          * @returns
         */
        "highlightLocation": (location: Location) => Promise<void>;
        /**
          * Set the component language. Default set to English (en). Will not react to changes.
          * @default 'en'
         */
        "language": string;
        /**
          * The MapsIndoors API key.
          * @type {string}
          * @default ''
         */
        "miApiKey": string;
        /**
          * Render the My Position Control as a Map Control at the given position.
          * @type {string}
         */
        "myPositionControlPosition": string;
        /**
          * Styling of polygon highlight when a location is clicked. Set it to null to turn off highlighting.
          * @type {object}
          * @default {         strokeColor: '#EF6CCE',         strokeOpacity: 1,         strokeWeight: 2,         fillColor: '#EF6CCE',         fillOpacity: 0.2     }
         */
        "polygonHighlightOptions": { strokeColor: string; strokeOpacity: number; strokeWeight: number; fillColor: string; fillOpacity: number; };
        /**
          * Styling of how the polyline looks when getting a route. Color: The stroke color of direction polyline on the map. Accepts any legal HTML color value. Default: '#307ad9'. Opacity: The stroke opacity of directions polylines on the map. Numerical value between 0.0 and 1.0. Default: 1. Weight: The width of the direction polyline in pixels. Default: 4.
          * @type {{ color: string, weight: number, opacity: number }}
          * @default {         color: '#3071d9',         opacity: 1,         weight: 4     }
         */
        "polylineOptions": { color: string, weight: number, opacity: number };
    }
    interface MiMapMapbox {
        /**
          * The MapBox access token.
          * @type {string}
         */
        "accessToken": string;
        /**
          * Set or get the bearing of the map.
          * @type {string}
          * @default '0'
         */
        "bearing": string;
        /**
          * Clear existing MapsIndoors location highlight.
          * @returns
         */
        "clearHighlightLocation": () => Promise<void>;
        /**
          * Set to true to prevent external links on the map from opening. This can be useful when running the map on a kiosk where you never want the browser to navigate away.
          * @type {boolean}
          * @default false
         */
        "disableExternalLinks": boolean;
        /**
          * Set or get the current floor index shown on the map.
          * @type {string}
         */
        "floorIndex": string;
        /**
          * Render the floor selector as a Map Control at the given position.
          * @type {('top-left' | 'top-right' | 'bottom-left' | 'bottom-right')}
         */
        "floorSelectorControlPosition": 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        /**
          * Get the MapsIndoors Directions Renderer Instance.
          * @returns
         */
        "getDirectionsRendererInstance": () => Promise<any>;
        /**
          * Get the MapsIndoors Directions Service Instance.
          * @returns
         */
        "getDirectionsServiceInstance": () => Promise<any>;
        /**
          * Get the map instance.
          * @returns
         */
        "getMapInstance": () => Promise<any>;
        /**
          * Get the MapsIndoors instance.
          * @returns
         */
        "getMapsIndoorsInstance": () => Promise<any>;
        /**
          * Highlight a MapsIndoors location. Only a single location can be highlighted at the time.
          * @param location
          * @returns
         */
        "highlightLocation": (location: Location) => Promise<void>;
        /**
          * Set the component language. Default set to English (en). Will not react to changes.
          * @default 'en'
         */
        "language": string;
        /**
          * Set or get the max pitch of the map (0-85).
          * @type {number}
          * @default 60
         */
        "maxPitch": number;
        /**
          * Set or get the max zoom level of the map.
          * @type {string}
          * @default undefined
         */
        "maxZoom": string;
        /**
          * The MapsIndoors API key.
          * @type {string}
          * @default ''
         */
        "miApiKey": string;
        /**
          * Render the My Position Control as a Map Control at the given position.
          * @type {('top-left' | 'top-right' | 'bottom-left' | 'bottom-right')}
         */
        "myPositionControlPosition": 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        /**
          * Set or get the pitch (tilt) of the map. Measured in degrees (0-60).
          * @type {string}
          * @default '0'
         */
        "pitch": string;
        /**
          * Styling of polygon highlight when a location is clicked. Set it to null to turn off highlighting.
          * @type {object}
          * @default {         strokeColor: '#EF6CCE',         strokeOpacity: 1,         strokeWeight: 2,         fillColor: '#EF6CCE',         fillOpacity: 0.2     }
         */
        "polygonHighlightOptions": { strokeColor: string; strokeOpacity: number; strokeWeight: number; fillColor: string; fillOpacity: number; };
        /**
          * Styling of how the polyline looks when getting a route. Color: The stroke color of direction polyline on the map. Accepts any legal HTML color value. Default: '#307ad9'. Opacity: The stroke opacity of directions polylines on the map. Numerical value between 0.0 and 1.0. Default: 1. Weight: The width of the direction polyline in pixels. Default: 4.
          * @type {{ color: string, weight: number, opacity: number }}
          * @default {         color: '#3071d9',         opacity: 1,         weight: 4     }
         */
        "polylineOptions": { color: string, weight: number, opacity: number };
        /**
          * Set or get the current zoom level of the map.
          * @type {string}
          * @default '17'
         */
        "zoom": string;
    }
    interface MiMetricCard {
        /**
          * This can be used for displaying an error message if there are no data to be displayed.
          * @type {string}
          * @memberof MetricCard
         */
        "error": string;
        /**
          * This is the metric title.
          * @type {string}
          * @memberof MetricCard
          * @default ''
         */
        "label": string;
        /**
          * When present a loading spinner will be displayed until the value or error attribute is set or the spinner attribute is removed
          * @type {boolean}
          * @memberof MetricCard
          * @default false
         */
        "spinner": boolean;
        /**
          * When present a info icon will be shown in the upper right corner of the card. When the mouse hovers over the icon tooltip will display the tip.
          * @type {string}
          * @memberof MetricCard
         */
        "tip": string;
        /**
          * This is the metric value.
          * @type {string}
          * @memberof MetricCard
          * @default ''
         */
        "value": string;
    }
    interface MiMyPosition {
        /**
          * Accepts a custom position provider instance (supports both legacy and modern interfaces). This is the external API - what users pass to the component. It's optional and may be undefined or invalid.
         */
        "customPositionProvider"?: IPositionProvider;
        /**
          * MapsIndoors instance.
         */
        "mapsindoors": any;
        /**
          * Reference: https://app.mapsindoors.com/mapsindoors/js/sdk/latest/docs/PositionControlOptions.html.
         */
        "myPositionOptions"?: any;
        /**
          * Sets a custom position. Works with any provider that implements setPosition. Uses this.positionProvider (the resolved provider) instead of this.customPositionProvider to ensure we're working with the validated, active provider.
         */
        "setPosition": (position: MapsIndoorsPosition) => Promise<void>;
        /**
          * Method for requesting the current position, emitting events and showing position on map based on result.
          * @param selfInvoked - Used to track if call was invoked by clicking on position control or not.
         */
        "watchPosition": (selfInvoked?: boolean) => Promise<void>;
    }
    interface MiNotification {
        /**
          * Clear all notifications.
          * @returns
         */
        "clearAll": () => Promise<void>;
        /**
          * Time the notification should be visible. Default value is 3.
          * @type {number} - Duration in seconds.
          * @default 3
         */
        "duration": number;
        /**
          * Where the notifications should be positioned.
          * @type {NotificationPosition}
          * @default NotificationPosition.BOTTOM_RIGHT
         */
        "position": NotificationPosition;
        /**
          * Show a notification.
          * @param message - Message to display.
          * @param type - Type of notification. Available types: 'info', 'warning', 'success', 'error' and 'none'.
          * @param sticky - Set message as sticky to prevent it from disappearing.
          * @returns
         */
        "push": (message: string, type?: string, sticky?: boolean) => Promise<void>;
    }
    interface MiRouteInstructions {
        /**
          * Set active step to populate it with an "active" class. Defaults to legIndex 0 and stepIndex 0.
          * @type {{ legIndex: number, stepIndex: number }}
          * @default {         legIndex: 0,         stepIndex: 0     }
         */
        "activeStep": { legIndex: number, stepIndex: number };
        /**
          * If the end location is a MapsIndoors location, provide it to have the instructions present it. The destinationLocation attribute wins over the destinationName attribute.
          * @type {Location}
         */
        "destinationLocation": Location;
        /**
          * If the end location is a external location, provide a name to have the instructions present it. The destination name will not be rendered when the destinationLocation attribute is set.
          * @type {string}
         */
        "destinationName": string;
        /**
          * If indoor substeps/maneuvers should be hidden.
          * @type {boolean}
          * @default false
         */
        "hideIndoorSubsteps": boolean;
        /**
          * If the origin location is a MapsIndoors location, provide it to have the instructions present it. The originLocation attribute wins over the originName attribute.
          * @type {Location}
         */
        "originLocation": Location;
        /**
          * If the origin location is a external location, provide a name to have the instructions present it. The origin name will not be rendered when the originLocation attribute is set.
          * @type {string}
         */
        "originName": string;
        /**
          * A MapsIndoors directions result object given from a getRoute call from DirectionsService.
          * @type {Route}
         */
        "route": Route;
        /**
          * Translations object for translatable labels.
          * @default {         walk: 'Walk',         bike: 'Bike',         transit: 'Transit',         drive: 'Drive',         leave: 'Leave',         from: 'From',         park: 'Park',         at: 'at',         building: 'Building',         venue: 'Venue',         takeStaircaseToLevel: 'Take staircase to level',         takeLadderToLevel: 'Take the ladder to level',         takeElevatorToLevel: 'Take elevator to level',         takeEscalatorToLevel: 'Take escalator to level',         takeWheelchairLiftToLevel: 'Take wheelchair lift to level',         takeWheelchairRampToLevel: 'Take wheelchair ramp to level',         exit: 'Exit',         enter: 'Enter',         stops: 'stops',         andContinue: 'and continue',         continueStraightAhead: 'Continue straight ahead',         goLeft: 'Go left',         goSharpLeft: 'Go sharp left',         goSlightLeft: 'Go slight left',         goRight: 'Go right',         goSharpRight: 'Go sharp right',         goSlightRight: 'Go slight right',         turnAround: 'Turn around',         days: 'd',         hours: 'h',         minutes: 'min',         rideTheBus: 'Ride the bus'     }
         */
        "translations": DirectionsTranslations;
        /**
          * Set preferred travel mode. Defaults to "walking".
          * @type {RouteTravelMode} 'walking', 'bicycling', 'transit', 'driving'.
          * @default RouteTravelMode.Walking
         */
        "travelMode": RouteTravelMode;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsHeading {
        /**
          * The destination location name.
          * @type {string}
         */
        "destinationName": string;
        /**
          * The origin location name.
          * @type {string}
         */
        "originName": string;
        /**
          * The total travel duration in seconds.
          * @type {number}
         */
        "totalTravelTime": number;
        /**
          * The total walking distance in meters.
          * @type {number}
         */
        "totalWalkingDistance": number;
        /**
          * @default {         from: 'From',         to: 'To',         avoidStairs: 'Avoid stairs',         walk: 'Walk',         walking: 'Walking',         bike: 'Bike',         bicycling: 'Bicycling',         transit: 'Transit',         car: 'Car',         driving: 'Driving'     }
         */
        "translations": { from: string; to: string; avoidStairs: string; walk: string; walking: string; bike: string; bicycling: string; transit: string; car: string; driving: string; };
        /**
          * Set preferred travel mode. Defaults to "walking".
          * @type {RouteTravelMode} 'walking', 'bicycling', 'transit', 'driving'.
          * @default RouteTravelMode.Walking
         */
        "travelMode": RouteTravelMode;
        /**
          * Set 'imperial' or 'metric' as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsManeuver {
        /**
          * Maneuver to display given as stringified JSON.
          * @type {string} - Maneuver/substep object passed as stringified JSON.
         */
        "maneuver": string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations": string;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsManeuverLegacy {
        /**
          * Maneuver to display given as stringified JSON.
          * @type {string} - Maneuver/substep object passed as stringified JSON.
         */
        "maneuver": string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations": string;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsStep {
        /**
          * Programmatically close the substeps.
         */
        "closeSubsteps": () => Promise<void>;
        /**
          * The route context of previous step, if any.
          * @type {string}
          * @default ''
         */
        "fromRouteContext": string;
        /**
          * The transit stop of previous step if any.
          * @type {string}
         */
        "fromTransitStop": string;
        /**
          * The travel mode of previous step, if any.
          * @type {string}
         */
        "fromTravelMode": string;
        /**
          * If indoor substeps/maneuvers should be hidden.
          * @type {boolean}
          * @default true
         */
        "hideIndoorSubsteps": boolean;
        /**
          * Programmatically open the substeps.
         */
        "openSubsteps": () => Promise<void>;
        /**
          * Indicates if it should show the toggle button.
          * @type {boolean}
          * @default true
         */
        "showToggleButton": boolean;
        /**
          * The step data object to render from. Must be passed as stringified JSON.
         */
        "step": string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations": string;
        /**
          * Set imperial or metric as default unit system. Default is Metric unless the browser is running US English. In that case Imperial.
          * @type {UnitSystem}
          * @default navigator.language === 'en-US' ? UnitSystem.Imperial : UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsStepLegacy {
        /**
          * The route context of previous step, if any.
          * @type {string}
          * @default ''
         */
        "fromRouteContext": string;
        /**
          * The transit stop of previous step if any.
          * @type {string}
         */
        "fromTransitStop": string;
        /**
          * The travel mode of previous step, if any.
          * @type {string}
         */
        "fromTravelMode": string;
        /**
          * If indoor substeps/maneuvers should be hidden.
          * @type {boolean}
          * @default true
         */
        "hideIndoorSubsteps": boolean;
        /**
          * The step data object to render from. Must be passed as stringified JSON.
         */
        "step": string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations": string;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit": UnitSystem;
    }
    interface MiScrollButtons {
        /**
          * Reference to the element with scroll on parent element.
          * @type {HTMLDivElement}
         */
        "scrollContainerElementRef": HTMLDivElement;
        /**
          * Determines how far to scroll when clicking one of the buttons. Default value is 100.
          * @type {number}
          * @default 100
         */
        "scrollLength": number;
        /**
          * Update scroll buttons enabled/disabled states.
         */
        "updateScrollButtons": () => Promise<any>;
        /**
          * Updates enable/disable state for scroll up and down buttons.
          * @returns
         */
        "updateScrollButtonsState": () => Promise<void>;
    }
    interface MiSearch {
        /**
          * Clear the input field.
         */
        "clear": () => Promise<void>;
        /**
          * Data attributes for the input field.
          * @default {}
         */
        "dataAttributes": { [key: string]: string };
        /**
          * Make the search field disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Set focus on the input field. The preventScroll boolean is passed as true to prevent the browser from scrolling the document to bring the newly-focused element into view.
         */
        "focusInput": () => Promise<void>;
        /**
          * Get hold of the search input field.
         */
        "getInputField": () => Promise<HTMLInputElement>;
        /**
          * Restrict Google Places search to a specific country (two-character, ISO 3166-1 Alpha-2 compatible country code)
         */
        "gmCountryCode": string;
        /**
          * If searching should include Google Places autocomplete suggestions.  Remember to comply to Google's policy by showing a "Power By Google" badge somewhere on your page if not already showing a Google map: https://developers.google.com/places/web-service/policies
          * @default false
         */
        "google": boolean;
        /**
          * Id for the input field.
          * @default ''
         */
        "idAttribute": string;
        /**
          * The language used when retrieving Google Places or Mapbox autocomplete suggestions.
          * @default 'en'
         */
        "language": string;
        /**
          * If searching should include Mapbox autocomplete suggestions.
          * @default false
         */
        "mapbox": boolean;
        /**
          * If searching should include MapsIndoors locations.
          * @default false
         */
        "mapsindoors": boolean;
        /**
          * Search only Mapsindoors locations within given categories. Accepts comma separated list of categories, eg. 'toilet,office'
         */
        "miCategories": string;
        /**
          * Which fields on MapsIndoors locations to search in. Comma separated string.
          * @default 'name,description,aliases,categories,externalId'
         */
        "miFields": string;
        /**
          * Search for MapsIndoors locations near a point. Can either be lat,lng coordinate as a string, eg. '-12.3456,45.6789' or a string in the format "type:id" e.g. "venue:586ca9f1bc1f5702406442b6"
         */
        "miNear": string;
        /**
          * Specify Mapsindoors search ordering
         */
        "miOrder": string;
        /**
          * Tell Mapsindoors to skip a number of results. Combine with miTake for pagination purposes.
         */
        "miSkip": number;
        /**
          * Restrict how many Mapsindoors results to request.
         */
        "miTake": number;
        /**
          * Restrict search results to a speficic venue (id or name)
         */
        "miVenue": string;
        /**
          * Placeholder for the input field.
          * @default ''
         */
        "placeholder": string;
        /**
          * The Mapbox Session Token used for getting Mapbox autocomplete suggestions.
         */
        "sessionToken": string;
        /**
          * Sets text to be shown in the search field. Setting it will not perform a search.
         */
        "setDisplayText": (displayText: string) => Promise<void>;
        /**
          * Programmatically trigger the search.
         */
        "triggerSearch": () => Promise<void>;
        /**
          * The user position which can determine the proximity for the Mapbox places results.
         */
        "userPosition": string;
        /**
          * Get or set the entered value
         */
        "value": string;
    }
    interface MiShareSms {
        /**
          * Default value for country code input field.
          * @type {string}
          * @default '1'
         */
        "countryCode": string;
        /**
          * MapsIndoors id for destination location.
          * @type {string}
         */
        "destinationLocationId": string;
        /**
          * MapsIndoors id for origin location.
          * @type {string}
         */
        "originLocationId": string;
        /**
          * Placeholder text for phone number input field.
          * @type {string}
          * @default 'Enter phone number'
         */
        "phoneNumberInputPlaceholder": string;
        /**
          * Label for submit button.
          * @type {string}
          * @default 'Send SMS'
         */
        "submitButtonLabel": string;
        /**
          * MapsIndoors venue id.
          * @type {string}
         */
        "venueId": string;
    }
    interface MiSpinner {
        /**
          * The inverse attribute will inverse the color of the spinner.
          * @type {boolean}
          * @default false
         */
        "inverse": boolean;
    }
    interface MiStepSwitcher {
        /**
          * Heading to display.
          * @type {string}
         */
        "heading": string;
        /**
          * Step index to show. Defaults to first step.
          * @type {number}
          * @default 0
         */
        "stepIndex": number;
        /**
          * Steps to display dots for.
          * @type {any[]}
          * @default []
         */
        "steps": any[];
    }
    interface MiTab {
        "label": string;
        "tabFor": string;
    }
    interface MiTabPanel {
        "active": (active?: boolean) => Promise<boolean>;
    }
    interface MiTabs {
        /**
          * @default 0
         */
        "active": number;
        /**
          * Sets a border surrounding the content view.
          * @default false
         */
        "bordered": boolean;
    }
    interface MiTime {
        /**
          * Time in seconds.
          * @type {string}
         */
        "seconds": number;
        /**
          * Object with translation strings as stringified JSON. Default translations {days: 'd', hours: 'h', minutes: 'min'}.
         */
        "translations": string;
    }
}
export interface MiColumnCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiColumnElement;
}
export interface MiComboBoxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiComboBoxElement;
}
export interface MiDataTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiDataTableElement;
}
export interface MiDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiDropdownElement;
}
export interface MiListItemCategoryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiListItemCategoryElement;
}
export interface MiListItemLocationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiListItemLocationElement;
}
export interface MiLocationBookingCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiLocationBookingElement;
}
export interface MiMapGooglemapsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiMapGooglemapsElement;
}
export interface MiMapMapboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiMapMapboxElement;
}
export interface MiMyPositionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiMyPositionElement;
}
export interface MiRouteInstructionsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiRouteInstructionsElement;
}
export interface MiRouteInstructionsStepCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiRouteInstructionsStepElement;
}
export interface MiRouteInstructionsStepLegacyCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiRouteInstructionsStepLegacyElement;
}
export interface MiSearchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiSearchElement;
}
export interface MiShareSmsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiShareSmsElement;
}
export interface MiStepSwitcherCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMiStepSwitcherElement;
}
declare global {
    interface HTMLComboBoxItemElement extends Components.ComboBoxItem, HTMLStencilElement {
    }
    var HTMLComboBoxItemElement: {
        prototype: HTMLComboBoxItemElement;
        new (): HTMLComboBoxItemElement;
    };
    interface HTMLMiCardElement extends Components.MiCard, HTMLStencilElement {
    }
    var HTMLMiCardElement: {
        prototype: HTMLMiCardElement;
        new (): HTMLMiCardElement;
    };
    interface HTMLMiChipElement extends Components.MiChip, HTMLStencilElement {
    }
    var HTMLMiChipElement: {
        prototype: HTMLMiChipElement;
        new (): HTMLMiChipElement;
    };
    interface HTMLMiColumnElementEventMap {
        "clicked": object;
    }
    interface HTMLMiColumnElement extends Components.MiColumn, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiColumnElementEventMap>(type: K, listener: (this: HTMLMiColumnElement, ev: MiColumnCustomEvent<HTMLMiColumnElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiColumnElementEventMap>(type: K, listener: (this: HTMLMiColumnElement, ev: MiColumnCustomEvent<HTMLMiColumnElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiColumnElement: {
        prototype: HTMLMiColumnElement;
        new (): HTMLMiColumnElement;
    };
    interface HTMLMiComboBoxElementEventMap {
        "change": any;
    }
    interface HTMLMiComboBoxElement extends Components.MiComboBox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiComboBoxElementEventMap>(type: K, listener: (this: HTMLMiComboBoxElement, ev: MiComboBoxCustomEvent<HTMLMiComboBoxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiComboBoxElementEventMap>(type: K, listener: (this: HTMLMiComboBoxElement, ev: MiComboBoxCustomEvent<HTMLMiComboBoxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiComboBoxElement: {
        prototype: HTMLMiComboBoxElement;
        new (): HTMLMiComboBoxElement;
    };
    interface HTMLMiDataTableElementEventMap {
        "selectionChanged": object;
    }
    interface HTMLMiDataTableElement extends Components.MiDataTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiDataTableElementEventMap>(type: K, listener: (this: HTMLMiDataTableElement, ev: MiDataTableCustomEvent<HTMLMiDataTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiDataTableElementEventMap>(type: K, listener: (this: HTMLMiDataTableElement, ev: MiDataTableCustomEvent<HTMLMiDataTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiDataTableElement: {
        prototype: HTMLMiDataTableElement;
        new (): HTMLMiDataTableElement;
    };
    interface HTMLMiDistanceElement extends Components.MiDistance, HTMLStencilElement {
    }
    var HTMLMiDistanceElement: {
        prototype: HTMLMiDistanceElement;
        new (): HTMLMiDistanceElement;
    };
    interface HTMLMiDropdownElementEventMap {
        "change": any;
        "cleared": void;
    }
    interface HTMLMiDropdownElement extends Components.MiDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiDropdownElementEventMap>(type: K, listener: (this: HTMLMiDropdownElement, ev: MiDropdownCustomEvent<HTMLMiDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiDropdownElementEventMap>(type: K, listener: (this: HTMLMiDropdownElement, ev: MiDropdownCustomEvent<HTMLMiDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiDropdownElement: {
        prototype: HTMLMiDropdownElement;
        new (): HTMLMiDropdownElement;
    };
    interface HTMLMiDropdownItemElement extends Components.MiDropdownItem, HTMLStencilElement {
    }
    var HTMLMiDropdownItemElement: {
        prototype: HTMLMiDropdownItemElement;
        new (): HTMLMiDropdownItemElement;
    };
    interface HTMLMiFloorSelectorElement extends Components.MiFloorSelector, HTMLStencilElement {
    }
    var HTMLMiFloorSelectorElement: {
        prototype: HTMLMiFloorSelectorElement;
        new (): HTMLMiFloorSelectorElement;
    };
    interface HTMLMiIconElement extends Components.MiIcon, HTMLStencilElement {
    }
    var HTMLMiIconElement: {
        prototype: HTMLMiIconElement;
        new (): HTMLMiIconElement;
    };
    interface HTMLMiKeyboardElement extends Components.MiKeyboard, HTMLStencilElement {
    }
    var HTMLMiKeyboardElement: {
        prototype: HTMLMiKeyboardElement;
        new (): HTMLMiKeyboardElement;
    };
    interface HTMLMiListElement extends Components.MiList, HTMLStencilElement {
    }
    var HTMLMiListElement: {
        prototype: HTMLMiListElement;
        new (): HTMLMiListElement;
    };
    interface HTMLMiListItemCategoryElementEventMap {
        "categoryClicked": any;
        "listItemDidRender": any;
    }
    interface HTMLMiListItemCategoryElement extends Components.MiListItemCategory, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiListItemCategoryElementEventMap>(type: K, listener: (this: HTMLMiListItemCategoryElement, ev: MiListItemCategoryCustomEvent<HTMLMiListItemCategoryElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiListItemCategoryElementEventMap>(type: K, listener: (this: HTMLMiListItemCategoryElement, ev: MiListItemCategoryCustomEvent<HTMLMiListItemCategoryElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiListItemCategoryElement: {
        prototype: HTMLMiListItemCategoryElement;
        new (): HTMLMiListItemCategoryElement;
    };
    interface HTMLMiListItemLocationElementEventMap {
        "locationClicked": any;
        "listItemDidRender": any;
    }
    interface HTMLMiListItemLocationElement extends Components.MiListItemLocation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiListItemLocationElementEventMap>(type: K, listener: (this: HTMLMiListItemLocationElement, ev: MiListItemLocationCustomEvent<HTMLMiListItemLocationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiListItemLocationElementEventMap>(type: K, listener: (this: HTMLMiListItemLocationElement, ev: MiListItemLocationCustomEvent<HTMLMiListItemLocationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiListItemLocationElement: {
        prototype: HTMLMiListItemLocationElement;
        new (): HTMLMiListItemLocationElement;
    };
    interface HTMLMiLocationBookingElementEventMap {
        "bookingCompleted": object;
        "bookingFailed": Error;
        "cancelCompleted": void;
        "cancelFailed": Error;
    }
    interface HTMLMiLocationBookingElement extends Components.MiLocationBooking, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiLocationBookingElementEventMap>(type: K, listener: (this: HTMLMiLocationBookingElement, ev: MiLocationBookingCustomEvent<HTMLMiLocationBookingElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiLocationBookingElementEventMap>(type: K, listener: (this: HTMLMiLocationBookingElement, ev: MiLocationBookingCustomEvent<HTMLMiLocationBookingElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiLocationBookingElement: {
        prototype: HTMLMiLocationBookingElement;
        new (): HTMLMiLocationBookingElement;
    };
    interface HTMLMiLocationInfoElement extends Components.MiLocationInfo, HTMLStencilElement {
    }
    var HTMLMiLocationInfoElement: {
        prototype: HTMLMiLocationInfoElement;
        new (): HTMLMiLocationInfoElement;
    };
    interface HTMLMiMapGooglemapsElementEventMap {
        "mapsIndoorsReady": any;
    }
    interface HTMLMiMapGooglemapsElement extends Components.MiMapGooglemaps, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiMapGooglemapsElementEventMap>(type: K, listener: (this: HTMLMiMapGooglemapsElement, ev: MiMapGooglemapsCustomEvent<HTMLMiMapGooglemapsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiMapGooglemapsElementEventMap>(type: K, listener: (this: HTMLMiMapGooglemapsElement, ev: MiMapGooglemapsCustomEvent<HTMLMiMapGooglemapsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiMapGooglemapsElement: {
        prototype: HTMLMiMapGooglemapsElement;
        new (): HTMLMiMapGooglemapsElement;
    };
    interface HTMLMiMapMapboxElementEventMap {
        "mapsIndoorsReady": any;
    }
    interface HTMLMiMapMapboxElement extends Components.MiMapMapbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiMapMapboxElementEventMap>(type: K, listener: (this: HTMLMiMapMapboxElement, ev: MiMapMapboxCustomEvent<HTMLMiMapMapboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiMapMapboxElementEventMap>(type: K, listener: (this: HTMLMiMapMapboxElement, ev: MiMapMapboxCustomEvent<HTMLMiMapMapboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiMapMapboxElement: {
        prototype: HTMLMiMapMapboxElement;
        new (): HTMLMiMapMapboxElement;
    };
    interface HTMLMiMetricCardElement extends Components.MiMetricCard, HTMLStencilElement {
    }
    var HTMLMiMetricCardElement: {
        prototype: HTMLMiMetricCardElement;
        new (): HTMLMiMetricCardElement;
    };
    interface HTMLMiMyPositionElementEventMap {
        "position_error": object;
        "position_received": object;
    }
    interface HTMLMiMyPositionElement extends Components.MiMyPosition, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiMyPositionElementEventMap>(type: K, listener: (this: HTMLMiMyPositionElement, ev: MiMyPositionCustomEvent<HTMLMiMyPositionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiMyPositionElementEventMap>(type: K, listener: (this: HTMLMiMyPositionElement, ev: MiMyPositionCustomEvent<HTMLMiMyPositionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiMyPositionElement: {
        prototype: HTMLMiMyPositionElement;
        new (): HTMLMiMyPositionElement;
    };
    interface HTMLMiNotificationElement extends Components.MiNotification, HTMLStencilElement {
    }
    var HTMLMiNotificationElement: {
        prototype: HTMLMiNotificationElement;
        new (): HTMLMiNotificationElement;
    };
    interface HTMLMiRouteInstructionsElementEventMap {
        "clicked": object;
    }
    interface HTMLMiRouteInstructionsElement extends Components.MiRouteInstructions, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiRouteInstructionsElementEventMap>(type: K, listener: (this: HTMLMiRouteInstructionsElement, ev: MiRouteInstructionsCustomEvent<HTMLMiRouteInstructionsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiRouteInstructionsElementEventMap>(type: K, listener: (this: HTMLMiRouteInstructionsElement, ev: MiRouteInstructionsCustomEvent<HTMLMiRouteInstructionsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiRouteInstructionsElement: {
        prototype: HTMLMiRouteInstructionsElement;
        new (): HTMLMiRouteInstructionsElement;
    };
    interface HTMLMiRouteInstructionsHeadingElement extends Components.MiRouteInstructionsHeading, HTMLStencilElement {
    }
    var HTMLMiRouteInstructionsHeadingElement: {
        prototype: HTMLMiRouteInstructionsHeadingElement;
        new (): HTMLMiRouteInstructionsHeadingElement;
    };
    interface HTMLMiRouteInstructionsManeuverElement extends Components.MiRouteInstructionsManeuver, HTMLStencilElement {
    }
    var HTMLMiRouteInstructionsManeuverElement: {
        prototype: HTMLMiRouteInstructionsManeuverElement;
        new (): HTMLMiRouteInstructionsManeuverElement;
    };
    interface HTMLMiRouteInstructionsManeuverLegacyElement extends Components.MiRouteInstructionsManeuverLegacy, HTMLStencilElement {
    }
    var HTMLMiRouteInstructionsManeuverLegacyElement: {
        prototype: HTMLMiRouteInstructionsManeuverLegacyElement;
        new (): HTMLMiRouteInstructionsManeuverLegacyElement;
    };
    interface HTMLMiRouteInstructionsStepElementEventMap {
        "stepClicked": object;
        "substepsToggled": void;
    }
    interface HTMLMiRouteInstructionsStepElement extends Components.MiRouteInstructionsStep, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiRouteInstructionsStepElementEventMap>(type: K, listener: (this: HTMLMiRouteInstructionsStepElement, ev: MiRouteInstructionsStepCustomEvent<HTMLMiRouteInstructionsStepElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiRouteInstructionsStepElementEventMap>(type: K, listener: (this: HTMLMiRouteInstructionsStepElement, ev: MiRouteInstructionsStepCustomEvent<HTMLMiRouteInstructionsStepElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiRouteInstructionsStepElement: {
        prototype: HTMLMiRouteInstructionsStepElement;
        new (): HTMLMiRouteInstructionsStepElement;
    };
    interface HTMLMiRouteInstructionsStepLegacyElementEventMap {
        "stepClicked": object;
    }
    interface HTMLMiRouteInstructionsStepLegacyElement extends Components.MiRouteInstructionsStepLegacy, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiRouteInstructionsStepLegacyElementEventMap>(type: K, listener: (this: HTMLMiRouteInstructionsStepLegacyElement, ev: MiRouteInstructionsStepLegacyCustomEvent<HTMLMiRouteInstructionsStepLegacyElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiRouteInstructionsStepLegacyElementEventMap>(type: K, listener: (this: HTMLMiRouteInstructionsStepLegacyElement, ev: MiRouteInstructionsStepLegacyCustomEvent<HTMLMiRouteInstructionsStepLegacyElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiRouteInstructionsStepLegacyElement: {
        prototype: HTMLMiRouteInstructionsStepLegacyElement;
        new (): HTMLMiRouteInstructionsStepLegacyElement;
    };
    interface HTMLMiScrollButtonsElement extends Components.MiScrollButtons, HTMLStencilElement {
    }
    var HTMLMiScrollButtonsElement: {
        prototype: HTMLMiScrollButtonsElement;
        new (): HTMLMiScrollButtonsElement;
    };
    interface HTMLMiSearchElementEventMap {
        "results": object[];
        "cleared": void;
        "componentRendered": void;
        "shortInput": void;
        "changed": void;
    }
    interface HTMLMiSearchElement extends Components.MiSearch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiSearchElementEventMap>(type: K, listener: (this: HTMLMiSearchElement, ev: MiSearchCustomEvent<HTMLMiSearchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiSearchElementEventMap>(type: K, listener: (this: HTMLMiSearchElement, ev: MiSearchCustomEvent<HTMLMiSearchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiSearchElement: {
        prototype: HTMLMiSearchElement;
        new (): HTMLMiSearchElement;
    };
    interface HTMLMiShareSmsElementEventMap {
        "successfullySent": any;
        "unsuccessfullySent": string;
    }
    interface HTMLMiShareSmsElement extends Components.MiShareSms, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiShareSmsElementEventMap>(type: K, listener: (this: HTMLMiShareSmsElement, ev: MiShareSmsCustomEvent<HTMLMiShareSmsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiShareSmsElementEventMap>(type: K, listener: (this: HTMLMiShareSmsElement, ev: MiShareSmsCustomEvent<HTMLMiShareSmsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiShareSmsElement: {
        prototype: HTMLMiShareSmsElement;
        new (): HTMLMiShareSmsElement;
    };
    interface HTMLMiSpinnerElement extends Components.MiSpinner, HTMLStencilElement {
    }
    var HTMLMiSpinnerElement: {
        prototype: HTMLMiSpinnerElement;
        new (): HTMLMiSpinnerElement;
    };
    interface HTMLMiStepSwitcherElementEventMap {
        "stepIndexChanged": number;
    }
    interface HTMLMiStepSwitcherElement extends Components.MiStepSwitcher, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMiStepSwitcherElementEventMap>(type: K, listener: (this: HTMLMiStepSwitcherElement, ev: MiStepSwitcherCustomEvent<HTMLMiStepSwitcherElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMiStepSwitcherElementEventMap>(type: K, listener: (this: HTMLMiStepSwitcherElement, ev: MiStepSwitcherCustomEvent<HTMLMiStepSwitcherElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMiStepSwitcherElement: {
        prototype: HTMLMiStepSwitcherElement;
        new (): HTMLMiStepSwitcherElement;
    };
    interface HTMLMiTabElement extends Components.MiTab, HTMLStencilElement {
    }
    var HTMLMiTabElement: {
        prototype: HTMLMiTabElement;
        new (): HTMLMiTabElement;
    };
    interface HTMLMiTabPanelElement extends Components.MiTabPanel, HTMLStencilElement {
    }
    var HTMLMiTabPanelElement: {
        prototype: HTMLMiTabPanelElement;
        new (): HTMLMiTabPanelElement;
    };
    interface HTMLMiTabsElement extends Components.MiTabs, HTMLStencilElement {
    }
    var HTMLMiTabsElement: {
        prototype: HTMLMiTabsElement;
        new (): HTMLMiTabsElement;
    };
    interface HTMLMiTimeElement extends Components.MiTime, HTMLStencilElement {
    }
    var HTMLMiTimeElement: {
        prototype: HTMLMiTimeElement;
        new (): HTMLMiTimeElement;
    };
    interface HTMLElementTagNameMap {
        "combo-box-item": HTMLComboBoxItemElement;
        "mi-card": HTMLMiCardElement;
        "mi-chip": HTMLMiChipElement;
        "mi-column": HTMLMiColumnElement;
        "mi-combo-box": HTMLMiComboBoxElement;
        "mi-data-table": HTMLMiDataTableElement;
        "mi-distance": HTMLMiDistanceElement;
        "mi-dropdown": HTMLMiDropdownElement;
        "mi-dropdown-item": HTMLMiDropdownItemElement;
        "mi-floor-selector": HTMLMiFloorSelectorElement;
        "mi-icon": HTMLMiIconElement;
        "mi-keyboard": HTMLMiKeyboardElement;
        "mi-list": HTMLMiListElement;
        "mi-list-item-category": HTMLMiListItemCategoryElement;
        "mi-list-item-location": HTMLMiListItemLocationElement;
        "mi-location-booking": HTMLMiLocationBookingElement;
        "mi-location-info": HTMLMiLocationInfoElement;
        "mi-map-googlemaps": HTMLMiMapGooglemapsElement;
        "mi-map-mapbox": HTMLMiMapMapboxElement;
        "mi-metric-card": HTMLMiMetricCardElement;
        "mi-my-position": HTMLMiMyPositionElement;
        "mi-notification": HTMLMiNotificationElement;
        "mi-route-instructions": HTMLMiRouteInstructionsElement;
        "mi-route-instructions-heading": HTMLMiRouteInstructionsHeadingElement;
        "mi-route-instructions-maneuver": HTMLMiRouteInstructionsManeuverElement;
        "mi-route-instructions-maneuver-legacy": HTMLMiRouteInstructionsManeuverLegacyElement;
        "mi-route-instructions-step": HTMLMiRouteInstructionsStepElement;
        "mi-route-instructions-step-legacy": HTMLMiRouteInstructionsStepLegacyElement;
        "mi-scroll-buttons": HTMLMiScrollButtonsElement;
        "mi-search": HTMLMiSearchElement;
        "mi-share-sms": HTMLMiShareSmsElement;
        "mi-spinner": HTMLMiSpinnerElement;
        "mi-step-switcher": HTMLMiStepSwitcherElement;
        "mi-tab": HTMLMiTabElement;
        "mi-tab-panel": HTMLMiTabPanelElement;
        "mi-tabs": HTMLMiTabsElement;
        "mi-time": HTMLMiTimeElement;
    }
}
declare namespace LocalJSX {
    type OneOf<K extends string, PropT, AttrT = PropT> = { [P in K]: PropT } & { [P in `attr:${K}` | `prop:${K}`]?: never } | { [P in `attr:${K}`]: AttrT } & { [P in K | `prop:${K}`]?: never } | { [P in `prop:${K}`]: PropT } & { [P in K | `attr:${K}`]?: never };

    interface ComboBoxItem {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "excludefromall"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean;
        "text"?: string;
        "value"?: string;
    }
    interface MiCard {
    }
    interface MiChip {
        /**
          * Checks if the chip is active and applies different styling to the component.
          * @type {boolean}
          * @default false
         */
        "active"?: boolean;
        /**
          * The background color of the chip. The default #005655 HEX value refers to the --brand-colors-dark-pine-100 from MIDT
          * @type {string}
          * @default '#005655'
         */
        "backgroundColor"?: string;
        /**
          * The chip content that is displayed in the component.
          * @type {string}
         */
        "content"?: string;
        /**
          * The icon source.
          * @type {string}
         */
        "icon"?: string;
    }
    interface MiColumn {
        /**
          * The alignContent property sets the alignment of the column's content.
          * @type {('left'|'center'|'right')}
          * @default 'left'
          * @example <mi-column align-content="center"></mi-column>
          * @memberof Column
         */
        "alignContent"?: string;
        /**
          * The name of the property on the row object which value will be displayed.
          * @type {string}
          * @memberof Column
         */
        "binding"?: string;
        /**
          * If present, the column width is fitted the content.
          * @type {boolean}
          * @memberof Column
          * @default false
         */
        "fitContent"?: boolean;
        /**
          * The label that will be shown in the table header.
          * @type {string}
          * @memberof Column
         */
        "label"?: string;
        /**
          * The monospace property sets the font-family to monospace.
          * @type {boolean}
          * @memberof Column
          * @default false
         */
        "monospace"?: boolean;
        /**
          * Fired when clicking on content within a table cell for this column. Event detail contains the row data.
          * @event clicked
          * @type {EventEmitter}
         */
        "onClicked"?: (event: MiColumnCustomEvent<object>) => void;
        /**
          * If present, the table will be pre-sorted by this column.
          * @type {('asc'|'desc')}
          * @memberof Column
         */
        "sort"?: string;
        /**
          * If present, the column will be sortable. *For sorting dates use `sortable="date"`.
          * @type {(''|'date'|'default')}
          * @memberof Column
         */
        "sortable"?: string;
        /**
          * The width property sets the column's width. All CSS length units are accepted.
          * @example <mi-column width="100px"></mi-column>
          * @type {string}
          * @default 'auto'
          * @memberof Column
         */
        "width"?: string;
    }
    interface MiComboBox {
        /**
          * Sets the disabled state for the dropdown.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * This attribute indicates that the items can be filtered using the input field present at the top. If it is not specified, the input field will not be visible, and filtering is not possible.
          * @type {boolean}
          * @default false
         */
        "filterable"?: boolean;
        /**
          * Gets or sets the list items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @returns 
          * @default []
         */
        "items"?: Array<HTMLMiDropdownItemElement>;
        /**
          * Sort order of items.
          * @type {SortOrder}
         */
        "itemsOrder"?: SortOrder;
        /**
          * Guiding message when presented with a content window that has no rows. Default language is English.
          * @default 'No results found'
         */
        "noResultsMessage"?: string;
        /**
          * Triggers an event when the selection is changed.
          * @type {EventEmitter}
         */
        "onChange"?: (event: MiComboBoxCustomEvent<any>) => void;
        /**
          * Gets or sets the state of the dropdown. If the attribute is set to true then the dropdown will be expanded.
          * @type {boolean}
          * @default false
         */
        "open"?: boolean;
        /**
          * Gets the selected items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @default []
         */
        "selected"?: Array<HTMLMiDropdownItemElement>;
    }
    interface MiDataTable {
        /**
          * Guiding message when presented with a table that has no rows.
          * @default 'No results found'
         */
        "emptyPageHeader"?: string;
        /**
          * Guiding message for actionable steps to be performed in order to render new search results.
         */
        "emptyPageSubheader"?: string;
        /**
          * Whether or not the table header should be sticky.
          * @default true
         */
        "isHeaderSticky"?: boolean;
        /**
          * The maximum number of rows to be displayed.
         */
        "maxRows"?: number;
        /**
          * Fired when selection of rows is changed. Event detail contains all the selected rows. This event is only relevant if the selectable attribute is present.
          * @event selectionChanged
         */
        "onSelectionChanged"?: (event: MiDataTableCustomEvent<object>) => void;
        /**
          * The page of rows to be displayed. Eg. If the maxRows is set to be less the total number of rows, the page property can specify which chunk of rows to show.
         */
        "page"?: number;
        /**
          * Array of objects for each row in the table.
          * @default []
         */
        "rows"?: Array<any>;
        /**
          * The selectable attribute specifies whether the first column in the table should be checkboxes. The header will be a select all or none checkbox.
          * @default false
         */
        "selectable"?: boolean;
        /**
          * The selected property contains a Set of all selected rows. This property is only relevant if the selectable attribute is present.
          * @default new Set()
         */
        "selected"?: Set<any>;
    }
    interface MiDistance {
        /**
          * Distance in meters.
          * @type {number}
         */
        "meters"?: number;
        /**
          * Set imperial or metric as default unit system. Default is Metric unless the browser is running US English. In that case Imperial.
          * @type {UnitSystem}
          * @default navigator.language === 'en-US' ? UnitSystem.Imperial : UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiDropdown {
        /**
          * Sets the disabled state for the dropdown.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Sets the alignment of the dropdown. The default alignment is 'left'.
          * @type {('right' | 'left')}
          * @default 'left'
         */
        "dropdownAlignment"?: 'right' | 'left';
        /**
          * This attribute indicates that the items can be filtered using the input field present at the top. If it is not specified, the input field will not be visible, and filtering is not possible.
          * @type {boolean}
          * @default false
         */
        "filterable"?: boolean;
        /**
          * Sets the alternative text for the icon.
         */
        "iconAlt"?: string;
        /**
          * Sets the icon on the left-hand side of the component.
         */
        "iconSrc"?: string;
        /**
          * Gets or sets the list items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @default []
         */
        "items"?: Array<HTMLMiDropdownItemElement>;
        /**
          * Sort order of items.
          * @type {SortOrder}
         */
        "itemsOrder"?: SortOrder;
        /**
          * The label will be displayed in as the text of the dropdown if the attribute multiple is present. Only required if multiple is present.
          * @type {string}
         */
        "label": string;
        /**
          * This attribute indicates that multiple items can be selected in the list. If it is not specified, then only one item can be selected at a time.
          * @type {boolean}
          * @default false
         */
        "multiple"?: boolean;
        /**
          * Guiding message when presented with a content window that has no rows. Default language is English.
          * @default 'No results found'
         */
        "noResultsMessage"?: string;
        /**
          * Triggers an event when the selection is changed.
          * @type {EventEmitter}
         */
        "onChange"?: (event: MiDropdownCustomEvent<any>) => void;
        /**
          * Emit an event when search field is cleared.
         */
        "onCleared"?: (event: MiDropdownCustomEvent<void>) => void;
        /**
          * Gets or sets the state of the dropdown. If the attribute is set to true then the dropdown will be expanded.
          * @type {boolean}
          * @default false
         */
        "open"?: boolean;
        /**
          * If present, it dictates placeholder for an filterable input field in the dropdown. Defaults to 'Type to filter...'.
          * @type {string}
          * @default 'Type to filter...'
         */
        "placeholder"?: string;
        /**
          * Gets the selected items.
          * @type {Array<HTMLMiDropdownItemElement>}
          * @default []
         */
        "selected"?: Array<HTMLMiDropdownItemElement>;
    }
    interface MiDropdownItem {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "excludefromall"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean;
        "text"?: string;
        "value"?: string;
    }
    interface MiFloorSelector {
        /**
          * MapsIndoors instance.
         */
        "mapsindoors"?: any;
        /**
          * The color to use as the primary color (as background color of the selected floor in the list).
          * @type {string}
          * @default '#005655'
         */
        "primaryColor"?: string;
    }
    interface MiIcon {
        /**
          * The icon name. A list of supported icons can be found in the documentation.
          * @type {string}
         */
        "iconName"?: string;
    }
    interface MiKeyboard {
        /**
          * The active input element.
          * @type {HTMLInputElement}
         */
        "inputElement"?: HTMLInputElement;
        /**
          * The keyboard language to use. Supported values are "en" (English), "fr" (French), "de", (German) and "da" (Danish). If omitted, the browser language will be used. Defaults to English.
         */
        "language"?: string;
        /**
          * The keyboard layout to use. Defaults to alphabetic.
          * @type {KeyboardLayout}
          * @default KeyboardLayout.Alphabetic
         */
        "layout"?: string;
    }
    interface MiList {
        /**
          * @description Determines if the MI Scroll Buttons Component should be rendered.
          * @type {boolean}
          * @default false
         */
        "scrollButtonsEnabled"?: boolean;
        /**
          * @description Determines how far to scroll when clicking one of the buttons from the MI Scroll Buttons Component.
          * @type {number}
          * @default 100
         */
        "scrollLength"?: number;
    }
    interface MiListItemCategory {
        /**
          * @description Array of Categories.
          * @type {Array<Category>}
         */
        "category"?: any;
        /**
          * @description Emits the clicked category.
          * @type {EventEmitter<Category>}
         */
        "onCategoryClicked"?: (event: MiListItemCategoryCustomEvent<any>) => void;
        /**
          * @description Emits a component render event.
          * @type {EventEmitter}
         */
        "onListItemDidRender"?: (event: MiListItemCategoryCustomEvent<any>) => void;
        /**
          * @description List orientation. Accepts the following values: 'vertical' and 'horizontal'.
          * @type {string}
          * @default 'vertical'
         */
        "orientation"?: string;
    }
    interface MiListItemLocation {
        /**
          * @description Optional URL to icon to render for the Location. If not set, imageURL on the Location data will be used.
          * @type {string}
         */
        "icon"?: string;
        /**
          * @description Add a badge to the location icon of the type given as value.
          * @type {string}
         */
        "iconBadge"?: string;
        /**
          * @description The value of the badge.
          * @type {string} For availability, use "true" or "false".
         */
        "iconBadgeValue"?: string;
        /**
          * @description The word used for "Level" when showing level info. Default is "Level".
          * @default 'Level'
         */
        "level"?: string;
        /**
          * @description Location object.
         */
        "location"?: any;
        /**
          * @description Emits a component render event.
          * @type {EventEmitter}
         */
        "onListItemDidRender"?: (event: MiListItemLocationCustomEvent<any>) => void;
        /**
          * @description Emits the clicked MI Location.
          * @type {EventEmitter<Location>}
         */
        "onLocationClicked"?: (event: MiListItemLocationCustomEvent<any>) => void;
        /**
          * Whether to show the External ID.
          * @default true
         */
        "showExternalId"?: boolean;
        /**
          * @description Set imperial or metric as unit for distance.
          * @type {UnitSystem}
         */
        "unit"?: UnitSystem;
    }
    interface MiLocationBooking {
        /**
          * The title of the created bookings. Defaults to "Booked".
          * @type {string}
          * @default 'Booked'
         */
        "bookingTitle"?: string;
        /**
          * Wether booking should be performed for 30 or 60 minutes.
          * @type {LocationBookingDuration}
          * @default LocationBookingDuration.min30
         */
        "duration"?: LocationBookingDuration;
        /**
          * MapsIndoors location to book.
          * @type {Location} MapsIndoors location
         */
        "location"?: Location;
        /**
          * Event fired when booking is completed.
          * @event bookingCompleted
          * @type {EventEmitter}
         */
        "onBookingCompleted"?: (event: MiLocationBookingCustomEvent<object>) => void;
        /**
          * Event fired in case booking failed.
          * @event bookingFailed
          * @type {EventEmitter}
         */
        "onBookingFailed"?: (event: MiLocationBookingCustomEvent<Error>) => void;
        /**
          * Event fired when booking is cancelled.
          * @type {EventEmitter}
         */
        "onCancelCompleted"?: (event: MiLocationBookingCustomEvent<void>) => void;
        /**
          * Event fired in case cancelling failed.
          * @type {EventEmitter}
         */
        "onCancelFailed"?: (event: MiLocationBookingCustomEvent<Error>) => void;
        /**
          * How many time slots to show going forward in time. Default to 4.
          * @default 4
         */
        "show"?: number;
        /**
          * No bookings will be allowed before this hour. Default value is 8.
          * @type {number} - the hour in 24h format
          * @default 8
         */
        "startHour"?: number;
        /**
          * No bookings will be allowed within and after this hour. Default value is 18.
          * @type {number} - the hour (0-23)
          * @default 18
         */
        "stopHour"?: number;
        /**
          * Translations object for translatable strings.
          * @default {         book: 'Book',         cancel: 'Cancel',         booked: 'Booked'     }
         */
        "translations"?: {
        book: string;
        cancel: string;
        booked: string;
    };
    }
    interface MiLocationInfo {
        /**
          * @description The word used for "Level" when showing level info. Default is "Level".
          * @default 'Level'
         */
        "level"?: string;
        /**
          * @description Location object.
         */
        "location"?: any;
        /**
          * @description Whether to show the External ID.
          * @default true
         */
        "showExternalId"?: boolean;
        /**
          * @description Whether to show the floor information. Default is true.
          * @default true
         */
        "showFloor"?: boolean;
    }
    interface MiMapGooglemaps {
        /**
          * Set to true to prevent external links on the map from opening. This can be useful when running the map on a kiosk where you never want the browser to navigate away.
          * @type {boolean}
          * @default false
         */
        "disableExternalLinks"?: boolean;
        /**
          * Set or get the current floor index shown on the map.
          * @type {string}
         */
        "floorIndex"?: string;
        /**
          * Render the floor selector as a Map Control at the given position.
          * @type {string}
         */
        "floorSelectorControlPosition"?: string;
        /**
          * The Google Maps API key.
          * @type {string}
          * @default ''
         */
        "gmApiKey"?: string;
        /**
          * Google Maps options. Defaults to zoom: 17, maxZoom: 21, center: { lat: 0, lng: 0 }, mapTypeControl: false, streetViewControl: false. https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
          * @type {google.maps.MapOptions}
          * @default {         zoom: 17,         maxZoom: 21,         center: { lat: 0, lng: 0 },         mapTypeControl: false,         streetViewControl: false     }
         */
        "gmOptions"?: google.maps.MapOptions;
        /**
          * Set the component language. Default set to English (en). Will not react to changes.
          * @default 'en'
         */
        "language"?: string;
        /**
          * The MapsIndoors API key.
          * @type {string}
          * @default ''
         */
        "miApiKey"?: string;
        /**
          * Render the My Position Control as a Map Control at the given position.
          * @type {string}
         */
        "myPositionControlPosition"?: string;
        /**
          * Ready event emitted when the MapsIndoors has been initialized and is ready.
          * @event ready
          * @type {EventEmitter}
         */
        "onMapsIndoorsReady"?: (event: MiMapGooglemapsCustomEvent<any>) => void;
        /**
          * Styling of polygon highlight when a location is clicked. Set it to null to turn off highlighting.
          * @type {object}
          * @default {         strokeColor: '#EF6CCE',         strokeOpacity: 1,         strokeWeight: 2,         fillColor: '#EF6CCE',         fillOpacity: 0.2     }
         */
        "polygonHighlightOptions"?: { strokeColor: string; strokeOpacity: number; strokeWeight: number; fillColor: string; fillOpacity: number; };
        /**
          * Styling of how the polyline looks when getting a route. Color: The stroke color of direction polyline on the map. Accepts any legal HTML color value. Default: '#307ad9'. Opacity: The stroke opacity of directions polylines on the map. Numerical value between 0.0 and 1.0. Default: 1. Weight: The width of the direction polyline in pixels. Default: 4.
          * @type {{ color: string, weight: number, opacity: number }}
          * @default {         color: '#3071d9',         opacity: 1,         weight: 4     }
         */
        "polylineOptions"?: { color: string, weight: number, opacity: number };
    }
    interface MiMapMapbox {
        /**
          * The MapBox access token.
          * @type {string}
         */
        "accessToken"?: string;
        /**
          * Set or get the bearing of the map.
          * @type {string}
          * @default '0'
         */
        "bearing"?: string;
        /**
          * Set to true to prevent external links on the map from opening. This can be useful when running the map on a kiosk where you never want the browser to navigate away.
          * @type {boolean}
          * @default false
         */
        "disableExternalLinks"?: boolean;
        /**
          * Set or get the current floor index shown on the map.
          * @type {string}
         */
        "floorIndex"?: string;
        /**
          * Render the floor selector as a Map Control at the given position.
          * @type {('top-left' | 'top-right' | 'bottom-left' | 'bottom-right')}
         */
        "floorSelectorControlPosition"?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        /**
          * Set the component language. Default set to English (en). Will not react to changes.
          * @default 'en'
         */
        "language"?: string;
        /**
          * Set or get the max pitch of the map (0-85).
          * @type {number}
          * @default 60
         */
        "maxPitch"?: number;
        /**
          * Set or get the max zoom level of the map.
          * @type {string}
          * @default undefined
         */
        "maxZoom"?: string;
        /**
          * The MapsIndoors API key.
          * @type {string}
          * @default ''
         */
        "miApiKey"?: string;
        /**
          * Render the My Position Control as a Map Control at the given position.
          * @type {('top-left' | 'top-right' | 'bottom-left' | 'bottom-right')}
         */
        "myPositionControlPosition"?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        /**
          * Ready event emitted when the MapsIndoors has been initialized and is ready.
          * @event ready
          * @type {EventEmitter}
         */
        "onMapsIndoorsReady"?: (event: MiMapMapboxCustomEvent<any>) => void;
        /**
          * Set or get the pitch (tilt) of the map. Measured in degrees (0-60).
          * @type {string}
          * @default '0'
         */
        "pitch"?: string;
        /**
          * Styling of polygon highlight when a location is clicked. Set it to null to turn off highlighting.
          * @type {object}
          * @default {         strokeColor: '#EF6CCE',         strokeOpacity: 1,         strokeWeight: 2,         fillColor: '#EF6CCE',         fillOpacity: 0.2     }
         */
        "polygonHighlightOptions"?: { strokeColor: string; strokeOpacity: number; strokeWeight: number; fillColor: string; fillOpacity: number; };
        /**
          * Styling of how the polyline looks when getting a route. Color: The stroke color of direction polyline on the map. Accepts any legal HTML color value. Default: '#307ad9'. Opacity: The stroke opacity of directions polylines on the map. Numerical value between 0.0 and 1.0. Default: 1. Weight: The width of the direction polyline in pixels. Default: 4.
          * @type {{ color: string, weight: number, opacity: number }}
          * @default {         color: '#3071d9',         opacity: 1,         weight: 4     }
         */
        "polylineOptions"?: { color: string, weight: number, opacity: number };
        /**
          * Set or get the current zoom level of the map.
          * @type {string}
          * @default '17'
         */
        "zoom"?: string;
    }
    interface MiMetricCard {
        /**
          * This can be used for displaying an error message if there are no data to be displayed.
          * @type {string}
          * @memberof MetricCard
         */
        "error"?: string;
        /**
          * This is the metric title.
          * @type {string}
          * @memberof MetricCard
          * @default ''
         */
        "label"?: string;
        /**
          * When present a loading spinner will be displayed until the value or error attribute is set or the spinner attribute is removed
          * @type {boolean}
          * @memberof MetricCard
          * @default false
         */
        "spinner"?: boolean;
        /**
          * When present a info icon will be shown in the upper right corner of the card. When the mouse hovers over the icon tooltip will display the tip.
          * @type {string}
          * @memberof MetricCard
         */
        "tip"?: string;
        /**
          * This is the metric value.
          * @type {string}
          * @memberof MetricCard
          * @default ''
         */
        "value"?: string;
    }
    interface MiMyPosition {
        /**
          * Accepts a custom position provider instance (supports both legacy and modern interfaces). This is the external API - what users pass to the component. It's optional and may be undefined or invalid.
         */
        "customPositionProvider"?: IPositionProvider;
        /**
          * MapsIndoors instance.
         */
        "mapsindoors"?: any;
        /**
          * Reference: https://app.mapsindoors.com/mapsindoors/js/sdk/latest/docs/PositionControlOptions.html.
         */
        "myPositionOptions"?: any;
        "onPosition_error"?: (event: MiMyPositionCustomEvent<object>) => void;
        "onPosition_received"?: (event: MiMyPositionCustomEvent<object>) => void;
    }
    interface MiNotification {
        /**
          * Time the notification should be visible. Default value is 3.
          * @type {number} - Duration in seconds.
          * @default 3
         */
        "duration"?: number;
        /**
          * Where the notifications should be positioned.
          * @type {NotificationPosition}
          * @default NotificationPosition.BOTTOM_RIGHT
         */
        "position"?: NotificationPosition;
    }
    interface MiRouteInstructions {
        /**
          * Set active step to populate it with an "active" class. Defaults to legIndex 0 and stepIndex 0.
          * @type {{ legIndex: number, stepIndex: number }}
          * @default {         legIndex: 0,         stepIndex: 0     }
         */
        "activeStep"?: { legIndex: number, stepIndex: number };
        /**
          * If the end location is a MapsIndoors location, provide it to have the instructions present it. The destinationLocation attribute wins over the destinationName attribute.
          * @type {Location}
         */
        "destinationLocation"?: Location;
        /**
          * If the end location is a external location, provide a name to have the instructions present it. The destination name will not be rendered when the destinationLocation attribute is set.
          * @type {string}
         */
        "destinationName"?: string;
        /**
          * If indoor substeps/maneuvers should be hidden.
          * @type {boolean}
          * @default false
         */
        "hideIndoorSubsteps"?: boolean;
        /**
          * Event emitted when clicking on instructions.
          * @event clicked
          * @type {object}
          * @property {number} legIndex
          * @property {number} stepIndex
          * @property {number} maneuverIndex
         */
        "onClicked"?: (event: MiRouteInstructionsCustomEvent<object>) => void;
        /**
          * If the origin location is a MapsIndoors location, provide it to have the instructions present it. The originLocation attribute wins over the originName attribute.
          * @type {Location}
         */
        "originLocation"?: Location;
        /**
          * If the origin location is a external location, provide a name to have the instructions present it. The origin name will not be rendered when the originLocation attribute is set.
          * @type {string}
         */
        "originName"?: string;
        /**
          * A MapsIndoors directions result object given from a getRoute call from DirectionsService.
          * @type {Route}
         */
        "route"?: Route;
        /**
          * Translations object for translatable labels.
          * @default {         walk: 'Walk',         bike: 'Bike',         transit: 'Transit',         drive: 'Drive',         leave: 'Leave',         from: 'From',         park: 'Park',         at: 'at',         building: 'Building',         venue: 'Venue',         takeStaircaseToLevel: 'Take staircase to level',         takeLadderToLevel: 'Take the ladder to level',         takeElevatorToLevel: 'Take elevator to level',         takeEscalatorToLevel: 'Take escalator to level',         takeWheelchairLiftToLevel: 'Take wheelchair lift to level',         takeWheelchairRampToLevel: 'Take wheelchair ramp to level',         exit: 'Exit',         enter: 'Enter',         stops: 'stops',         andContinue: 'and continue',         continueStraightAhead: 'Continue straight ahead',         goLeft: 'Go left',         goSharpLeft: 'Go sharp left',         goSlightLeft: 'Go slight left',         goRight: 'Go right',         goSharpRight: 'Go sharp right',         goSlightRight: 'Go slight right',         turnAround: 'Turn around',         days: 'd',         hours: 'h',         minutes: 'min',         rideTheBus: 'Ride the bus'     }
         */
        "translations"?: DirectionsTranslations;
        /**
          * Set preferred travel mode. Defaults to "walking".
          * @type {RouteTravelMode} 'walking', 'bicycling', 'transit', 'driving'.
          * @default RouteTravelMode.Walking
         */
        "travelMode"?: RouteTravelMode;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiRouteInstructionsHeading {
        /**
          * The destination location name.
          * @type {string}
         */
        "destinationName"?: string;
        /**
          * The origin location name.
          * @type {string}
         */
        "originName"?: string;
        /**
          * The total travel duration in seconds.
          * @type {number}
         */
        "totalTravelTime"?: number;
        /**
          * The total walking distance in meters.
          * @type {number}
         */
        "totalWalkingDistance"?: number;
        /**
          * @default {         from: 'From',         to: 'To',         avoidStairs: 'Avoid stairs',         walk: 'Walk',         walking: 'Walking',         bike: 'Bike',         bicycling: 'Bicycling',         transit: 'Transit',         car: 'Car',         driving: 'Driving'     }
         */
        "translations"?: { from: string; to: string; avoidStairs: string; walk: string; walking: string; bike: string; bicycling: string; transit: string; car: string; driving: string; };
        /**
          * Set preferred travel mode. Defaults to "walking".
          * @type {RouteTravelMode} 'walking', 'bicycling', 'transit', 'driving'.
          * @default RouteTravelMode.Walking
         */
        "travelMode"?: RouteTravelMode;
        /**
          * Set 'imperial' or 'metric' as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiRouteInstructionsManeuver {
        /**
          * Maneuver to display given as stringified JSON.
          * @type {string} - Maneuver/substep object passed as stringified JSON.
         */
        "maneuver"?: string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations"?: string;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiRouteInstructionsManeuverLegacy {
        /**
          * Maneuver to display given as stringified JSON.
          * @type {string} - Maneuver/substep object passed as stringified JSON.
         */
        "maneuver"?: string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations"?: string;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiRouteInstructionsStep {
        /**
          * The route context of previous step, if any.
          * @type {string}
          * @default ''
         */
        "fromRouteContext"?: string;
        /**
          * The transit stop of previous step if any.
          * @type {string}
         */
        "fromTransitStop"?: string;
        /**
          * The travel mode of previous step, if any.
          * @type {string}
         */
        "fromTravelMode"?: string;
        /**
          * If indoor substeps/maneuvers should be hidden.
          * @type {boolean}
          * @default true
         */
        "hideIndoorSubsteps"?: boolean;
        /**
          * Event emitted when clicking on a step (not sub step).
          * @event stepClicked
          * @type {object}
         */
        "onStepClicked"?: (event: MiRouteInstructionsStepCustomEvent<object>) => void;
        /**
          * Event emitted when substeps are toggled.
         */
        "onSubstepsToggled"?: (event: MiRouteInstructionsStepCustomEvent<void>) => void;
        /**
          * Indicates if it should show the toggle button.
          * @type {boolean}
          * @default true
         */
        "showToggleButton"?: boolean;
        /**
          * The step data object to render from. Must be passed as stringified JSON.
         */
        "step"?: string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations"?: string;
        /**
          * Set imperial or metric as default unit system. Default is Metric unless the browser is running US English. In that case Imperial.
          * @type {UnitSystem}
          * @default navigator.language === 'en-US' ? UnitSystem.Imperial : UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiRouteInstructionsStepLegacy {
        /**
          * The route context of previous step, if any.
          * @type {string}
          * @default ''
         */
        "fromRouteContext"?: string;
        /**
          * The transit stop of previous step if any.
          * @type {string}
         */
        "fromTransitStop"?: string;
        /**
          * The travel mode of previous step, if any.
          * @type {string}
         */
        "fromTravelMode"?: string;
        /**
          * If indoor substeps/maneuvers should be hidden.
          * @type {boolean}
          * @default true
         */
        "hideIndoorSubsteps"?: boolean;
        /**
          * Event emitted when clicking on a step (not sub step).
          * @event stepClicked
          * @type {object}
          * @properties Object
         */
        "onStepClicked"?: (event: MiRouteInstructionsStepLegacyCustomEvent<object>) => void;
        /**
          * The step data object to render from. Must be passed as stringified JSON.
         */
        "step"?: string;
        /**
          * Object with translation strings as stringified JSON.
         */
        "translations"?: string;
        /**
          * Set imperial or metric as default unit system.
          * @type {UnitSystem} 'imperial' or 'metric'
          * @default UnitSystem.Metric
         */
        "unit"?: UnitSystem;
    }
    interface MiScrollButtons {
        /**
          * Reference to the element with scroll on parent element.
          * @type {HTMLDivElement}
         */
        "scrollContainerElementRef"?: HTMLDivElement;
        /**
          * Determines how far to scroll when clicking one of the buttons. Default value is 100.
          * @type {number}
          * @default 100
         */
        "scrollLength"?: number;
    }
    interface MiSearch {
        /**
          * Data attributes for the input field.
          * @default {}
         */
        "dataAttributes"?: { [key: string]: string };
        /**
          * Make the search field disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Restrict Google Places search to a specific country (two-character, ISO 3166-1 Alpha-2 compatible country code)
         */
        "gmCountryCode"?: string;
        /**
          * If searching should include Google Places autocomplete suggestions.  Remember to comply to Google's policy by showing a "Power By Google" badge somewhere on your page if not already showing a Google map: https://developers.google.com/places/web-service/policies
          * @default false
         */
        "google"?: boolean;
        /**
          * Id for the input field.
          * @default ''
         */
        "idAttribute"?: string;
        /**
          * The language used when retrieving Google Places or Mapbox autocomplete suggestions.
          * @default 'en'
         */
        "language"?: string;
        /**
          * If searching should include Mapbox autocomplete suggestions.
          * @default false
         */
        "mapbox"?: boolean;
        /**
          * If searching should include MapsIndoors locations.
          * @default false
         */
        "mapsindoors"?: boolean;
        /**
          * Search only Mapsindoors locations within given categories. Accepts comma separated list of categories, eg. 'toilet,office'
         */
        "miCategories"?: string;
        /**
          * Which fields on MapsIndoors locations to search in. Comma separated string.
          * @default 'name,description,aliases,categories,externalId'
         */
        "miFields"?: string;
        /**
          * Search for MapsIndoors locations near a point. Can either be lat,lng coordinate as a string, eg. '-12.3456,45.6789' or a string in the format "type:id" e.g. "venue:586ca9f1bc1f5702406442b6"
         */
        "miNear"?: string;
        /**
          * Specify Mapsindoors search ordering
         */
        "miOrder"?: string;
        /**
          * Tell Mapsindoors to skip a number of results. Combine with miTake for pagination purposes.
         */
        "miSkip"?: number;
        /**
          * Restrict how many Mapsindoors results to request.
         */
        "miTake"?: number;
        /**
          * Restrict search results to a speficic venue (id or name)
         */
        "miVenue"?: string;
        /**
          * Event emitted whenever the value of the input field has changed.
         */
        "onChanged"?: (event: MiSearchCustomEvent<void>) => void;
        /**
          * Event emitted when the search field is emptied.
         */
        "onCleared"?: (event: MiSearchCustomEvent<void>) => void;
        /**
          * Event emitted after every component rendering.
         */
        "onComponentRendered"?: (event: MiSearchCustomEvent<void>) => void;
        /**
          * Event emitted when searching is complete.
         */
        "onResults"?: (event: MiSearchCustomEvent<object[]>) => void;
        /**
          * Event emitted whenever the search field contains only one character.
         */
        "onShortInput"?: (event: MiSearchCustomEvent<void>) => void;
        /**
          * Placeholder for the input field.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * The Mapbox Session Token used for getting Mapbox autocomplete suggestions.
         */
        "sessionToken"?: string;
        /**
          * The user position which can determine the proximity for the Mapbox places results.
         */
        "userPosition"?: string;
        /**
          * Get or set the entered value
         */
        "value"?: string;
    }
    interface MiShareSms {
        /**
          * Default value for country code input field.
          * @type {string}
          * @default '1'
         */
        "countryCode"?: string;
        /**
          * MapsIndoors id for destination location.
          * @type {string}
         */
        "destinationLocationId"?: string;
        /**
          * Emits a success event when the SMS is send.
          * @type {EventEmitter}
         */
        "onSuccessfullySent"?: (event: MiShareSmsCustomEvent<any>) => void;
        /**
          * Emits a error message when the SMS wasn't send.
          * @type {EventEmitter<string>}
         */
        "onUnsuccessfullySent"?: (event: MiShareSmsCustomEvent<string>) => void;
        /**
          * MapsIndoors id for origin location.
          * @type {string}
         */
        "originLocationId"?: string;
        /**
          * Placeholder text for phone number input field.
          * @type {string}
          * @default 'Enter phone number'
         */
        "phoneNumberInputPlaceholder"?: string;
        /**
          * Label for submit button.
          * @type {string}
          * @default 'Send SMS'
         */
        "submitButtonLabel"?: string;
        /**
          * MapsIndoors venue id.
          * @type {string}
         */
        "venueId"?: string;
    }
    interface MiSpinner {
        /**
          * The inverse attribute will inverse the color of the spinner.
          * @type {boolean}
          * @default false
         */
        "inverse"?: boolean;
    }
    interface MiStepSwitcher {
        /**
          * Heading to display.
          * @type {string}
         */
        "heading"?: string;
        /**
          * Emits the new step index as a number.
          * @type {EventEmitter}
         */
        "onStepIndexChanged"?: (event: MiStepSwitcherCustomEvent<number>) => void;
        /**
          * Step index to show. Defaults to first step.
          * @type {number}
          * @default 0
         */
        "stepIndex"?: number;
        /**
          * Steps to display dots for.
          * @type {any[]}
          * @default []
         */
        "steps"?: any[];
    }
    interface MiTab {
        "label"?: string;
        "tabFor"?: string;
    }
    interface MiTabPanel {
    }
    interface MiTabs {
        /**
          * @default 0
         */
        "active"?: number;
        /**
          * Sets a border surrounding the content view.
          * @default false
         */
        "bordered"?: boolean;
    }
    interface MiTime {
        /**
          * Time in seconds.
          * @type {string}
         */
        "seconds"?: number;
        /**
          * Object with translation strings as stringified JSON. Default translations {days: 'd', hours: 'h', minutes: 'min'}.
         */
        "translations"?: string;
    }

    interface ComboBoxItemAttributes {
        "selected": boolean;
        "disabled": boolean;
        "excludefromall": boolean;
        "value": string;
        "text": string;
    }
    interface MiChipAttributes {
        "icon": string;
        "content": string;
        "backgroundColor": string;
        "active": boolean;
    }
    interface MiColumnAttributes {
        "monospace": boolean;
        "alignContent": string;
        "label": string;
        "sortable": string;
        "sort": string;
        "binding": string;
        "fitContent": boolean;
        "width": string;
    }
    interface MiComboBoxAttributes {
        "open": boolean;
        "itemsOrder": SortOrder;
        "filterable": boolean;
        "noResultsMessage": string;
        "disabled": boolean;
    }
    interface MiDataTableAttributes {
        "maxRows": number;
        "page": number;
        "selectable": boolean;
        "emptyPageHeader": string;
        "emptyPageSubheader": string;
        "isHeaderSticky": boolean;
    }
    interface MiDistanceAttributes {
        "meters": number;
        "unit": UnitSystem;
    }
    interface MiDropdownAttributes {
        "open": boolean;
        "itemsOrder": SortOrder;
        "label": string;
        "filterable": boolean;
        "placeholder": string;
        "multiple": boolean;
        "noResultsMessage": string;
        "iconSrc": string;
        "iconAlt": string;
        "dropdownAlignment": 'right' | 'left';
        "disabled": boolean;
    }
    interface MiDropdownItemAttributes {
        "selected": boolean;
        "disabled": boolean;
        "excludefromall": boolean;
        "value": string;
        "text": string;
    }
    interface MiFloorSelectorAttributes {
        "mapsindoors": string;
        "primaryColor": string;
    }
    interface MiIconAttributes {
        "iconName": string;
    }
    interface MiKeyboardAttributes {
        "layout": string;
        "language": string;
    }
    interface MiListAttributes {
        "scrollButtonsEnabled": boolean;
        "scrollLength": number;
    }
    interface MiListItemCategoryAttributes {
        "category": string;
        "orientation": string;
    }
    interface MiListItemLocationAttributes {
        "location": string;
        "showExternalId": boolean;
        "unit": UnitSystem;
        "icon": string;
        "level": string;
        "iconBadge": string;
        "iconBadgeValue": string;
    }
    interface MiLocationBookingAttributes {
        "duration": LocationBookingDuration;
        "show": number;
        "startHour": number;
        "stopHour": number;
        "bookingTitle": string;
    }
    interface MiLocationInfoAttributes {
        "location": string;
        "level": string;
        "showExternalId": boolean;
        "showFloor": boolean;
    }
    interface MiMapGooglemapsAttributes {
        "gmApiKey": string;
        "miApiKey": string;
        "disableExternalLinks": boolean;
        "floorSelectorControlPosition": string;
        "floorIndex": string;
        "myPositionControlPosition": string;
        "language": string;
    }
    interface MiMapMapboxAttributes {
        "accessToken": string;
        "miApiKey": string;
        "disableExternalLinks": boolean;
        "floorSelectorControlPosition": 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        "floorIndex": string;
        "myPositionControlPosition": 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
        "zoom": string;
        "maxPitch": number;
        "maxZoom": string;
        "bearing": string;
        "pitch": string;
        "language": string;
    }
    interface MiMetricCardAttributes {
        "label": string;
        "value": string;
        "tip": string;
        "spinner": boolean;
        "error": string;
    }
    interface MiMyPositionAttributes {
        "mapsindoors": string;
        "myPositionOptions": string;
    }
    interface MiNotificationAttributes {
        "position": NotificationPosition;
        "duration": number;
    }
    interface MiRouteInstructionsAttributes {
        "unit": UnitSystem;
        "hideIndoorSubsteps": boolean;
        "travelMode": RouteTravelMode;
        "originName": string;
        "destinationName": string;
    }
    interface MiRouteInstructionsHeadingAttributes {
        "originName": string;
        "destinationName": string;
        "totalTravelTime": number;
        "totalWalkingDistance": number;
        "travelMode": RouteTravelMode;
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsManeuverAttributes {
        "maneuver": string;
        "translations": string;
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsManeuverLegacyAttributes {
        "maneuver": string;
        "translations": string;
        "unit": UnitSystem;
    }
    interface MiRouteInstructionsStepAttributes {
        "step": string;
        "hideIndoorSubsteps": boolean;
        "fromRouteContext": string;
        "fromTravelMode": string;
        "fromTransitStop": string;
        "unit": UnitSystem;
        "showToggleButton": boolean;
        "translations": string;
    }
    interface MiRouteInstructionsStepLegacyAttributes {
        "step": string;
        "hideIndoorSubsteps": boolean;
        "fromRouteContext": string;
        "fromTravelMode": string;
        "fromTransitStop": string;
        "unit": UnitSystem;
        "translations": string;
    }
    interface MiScrollButtonsAttributes {
        "scrollLength": number;
    }
    interface MiSearchAttributes {
        "placeholder": string;
        "idAttribute": string;
        "mapsindoors": boolean;
        "google": boolean;
        "mapbox": boolean;
        "language": string;
        "miFields": string;
        "miTake": number;
        "miSkip": number;
        "miOrder": string;
        "miCategories": string;
        "miNear": string;
        "miVenue": string;
        "gmCountryCode": string;
        "value": string;
        "disabled": boolean;
        "sessionToken": string;
        "userPosition": string;
    }
    interface MiShareSmsAttributes {
        "venueId": string;
        "originLocationId": string;
        "destinationLocationId": string;
        "countryCode": string;
        "phoneNumberInputPlaceholder": string;
        "submitButtonLabel": string;
    }
    interface MiSpinnerAttributes {
        "inverse": boolean;
    }
    interface MiStepSwitcherAttributes {
        "heading": string;
        "stepIndex": number;
    }
    interface MiTabAttributes {
        "label": string;
        "tabFor": string;
    }
    interface MiTabsAttributes {
        "active": number;
        "bordered": boolean;
    }
    interface MiTimeAttributes {
        "seconds": number;
        "translations": string;
    }

    interface IntrinsicElements {
        "combo-box-item": Omit<ComboBoxItem, keyof ComboBoxItemAttributes> & { [K in keyof ComboBoxItem & keyof ComboBoxItemAttributes]?: ComboBoxItem[K] } & { [K in keyof ComboBoxItem & keyof ComboBoxItemAttributes as `attr:${K}`]?: ComboBoxItemAttributes[K] } & { [K in keyof ComboBoxItem & keyof ComboBoxItemAttributes as `prop:${K}`]?: ComboBoxItem[K] };
        "mi-card": MiCard;
        "mi-chip": Omit<MiChip, keyof MiChipAttributes> & { [K in keyof MiChip & keyof MiChipAttributes]?: MiChip[K] } & { [K in keyof MiChip & keyof MiChipAttributes as `attr:${K}`]?: MiChipAttributes[K] } & { [K in keyof MiChip & keyof MiChipAttributes as `prop:${K}`]?: MiChip[K] };
        "mi-column": Omit<MiColumn, keyof MiColumnAttributes> & { [K in keyof MiColumn & keyof MiColumnAttributes]?: MiColumn[K] } & { [K in keyof MiColumn & keyof MiColumnAttributes as `attr:${K}`]?: MiColumnAttributes[K] } & { [K in keyof MiColumn & keyof MiColumnAttributes as `prop:${K}`]?: MiColumn[K] };
        "mi-combo-box": Omit<MiComboBox, keyof MiComboBoxAttributes> & { [K in keyof MiComboBox & keyof MiComboBoxAttributes]?: MiComboBox[K] } & { [K in keyof MiComboBox & keyof MiComboBoxAttributes as `attr:${K}`]?: MiComboBoxAttributes[K] } & { [K in keyof MiComboBox & keyof MiComboBoxAttributes as `prop:${K}`]?: MiComboBox[K] };
        "mi-data-table": Omit<MiDataTable, keyof MiDataTableAttributes> & { [K in keyof MiDataTable & keyof MiDataTableAttributes]?: MiDataTable[K] } & { [K in keyof MiDataTable & keyof MiDataTableAttributes as `attr:${K}`]?: MiDataTableAttributes[K] } & { [K in keyof MiDataTable & keyof MiDataTableAttributes as `prop:${K}`]?: MiDataTable[K] };
        "mi-distance": Omit<MiDistance, keyof MiDistanceAttributes> & { [K in keyof MiDistance & keyof MiDistanceAttributes]?: MiDistance[K] } & { [K in keyof MiDistance & keyof MiDistanceAttributes as `attr:${K}`]?: MiDistanceAttributes[K] } & { [K in keyof MiDistance & keyof MiDistanceAttributes as `prop:${K}`]?: MiDistance[K] };
        "mi-dropdown": Omit<MiDropdown, keyof MiDropdownAttributes> & { [K in keyof MiDropdown & keyof MiDropdownAttributes]?: MiDropdown[K] } & { [K in keyof MiDropdown & keyof MiDropdownAttributes as `attr:${K}`]?: MiDropdownAttributes[K] } & { [K in keyof MiDropdown & keyof MiDropdownAttributes as `prop:${K}`]?: MiDropdown[K] } & OneOf<"label", MiDropdown["label"], MiDropdownAttributes["label"]>;
        "mi-dropdown-item": Omit<MiDropdownItem, keyof MiDropdownItemAttributes> & { [K in keyof MiDropdownItem & keyof MiDropdownItemAttributes]?: MiDropdownItem[K] } & { [K in keyof MiDropdownItem & keyof MiDropdownItemAttributes as `attr:${K}`]?: MiDropdownItemAttributes[K] } & { [K in keyof MiDropdownItem & keyof MiDropdownItemAttributes as `prop:${K}`]?: MiDropdownItem[K] };
        "mi-floor-selector": Omit<MiFloorSelector, keyof MiFloorSelectorAttributes> & { [K in keyof MiFloorSelector & keyof MiFloorSelectorAttributes]?: MiFloorSelector[K] } & { [K in keyof MiFloorSelector & keyof MiFloorSelectorAttributes as `attr:${K}`]?: MiFloorSelectorAttributes[K] } & { [K in keyof MiFloorSelector & keyof MiFloorSelectorAttributes as `prop:${K}`]?: MiFloorSelector[K] };
        "mi-icon": Omit<MiIcon, keyof MiIconAttributes> & { [K in keyof MiIcon & keyof MiIconAttributes]?: MiIcon[K] } & { [K in keyof MiIcon & keyof MiIconAttributes as `attr:${K}`]?: MiIconAttributes[K] } & { [K in keyof MiIcon & keyof MiIconAttributes as `prop:${K}`]?: MiIcon[K] };
        "mi-keyboard": Omit<MiKeyboard, keyof MiKeyboardAttributes> & { [K in keyof MiKeyboard & keyof MiKeyboardAttributes]?: MiKeyboard[K] } & { [K in keyof MiKeyboard & keyof MiKeyboardAttributes as `attr:${K}`]?: MiKeyboardAttributes[K] } & { [K in keyof MiKeyboard & keyof MiKeyboardAttributes as `prop:${K}`]?: MiKeyboard[K] };
        "mi-list": Omit<MiList, keyof MiListAttributes> & { [K in keyof MiList & keyof MiListAttributes]?: MiList[K] } & { [K in keyof MiList & keyof MiListAttributes as `attr:${K}`]?: MiListAttributes[K] } & { [K in keyof MiList & keyof MiListAttributes as `prop:${K}`]?: MiList[K] };
        "mi-list-item-category": Omit<MiListItemCategory, keyof MiListItemCategoryAttributes> & { [K in keyof MiListItemCategory & keyof MiListItemCategoryAttributes]?: MiListItemCategory[K] } & { [K in keyof MiListItemCategory & keyof MiListItemCategoryAttributes as `attr:${K}`]?: MiListItemCategoryAttributes[K] } & { [K in keyof MiListItemCategory & keyof MiListItemCategoryAttributes as `prop:${K}`]?: MiListItemCategory[K] };
        "mi-list-item-location": Omit<MiListItemLocation, keyof MiListItemLocationAttributes> & { [K in keyof MiListItemLocation & keyof MiListItemLocationAttributes]?: MiListItemLocation[K] } & { [K in keyof MiListItemLocation & keyof MiListItemLocationAttributes as `attr:${K}`]?: MiListItemLocationAttributes[K] } & { [K in keyof MiListItemLocation & keyof MiListItemLocationAttributes as `prop:${K}`]?: MiListItemLocation[K] };
        "mi-location-booking": Omit<MiLocationBooking, keyof MiLocationBookingAttributes> & { [K in keyof MiLocationBooking & keyof MiLocationBookingAttributes]?: MiLocationBooking[K] } & { [K in keyof MiLocationBooking & keyof MiLocationBookingAttributes as `attr:${K}`]?: MiLocationBookingAttributes[K] } & { [K in keyof MiLocationBooking & keyof MiLocationBookingAttributes as `prop:${K}`]?: MiLocationBooking[K] };
        "mi-location-info": Omit<MiLocationInfo, keyof MiLocationInfoAttributes> & { [K in keyof MiLocationInfo & keyof MiLocationInfoAttributes]?: MiLocationInfo[K] } & { [K in keyof MiLocationInfo & keyof MiLocationInfoAttributes as `attr:${K}`]?: MiLocationInfoAttributes[K] } & { [K in keyof MiLocationInfo & keyof MiLocationInfoAttributes as `prop:${K}`]?: MiLocationInfo[K] };
        "mi-map-googlemaps": Omit<MiMapGooglemaps, keyof MiMapGooglemapsAttributes> & { [K in keyof MiMapGooglemaps & keyof MiMapGooglemapsAttributes]?: MiMapGooglemaps[K] } & { [K in keyof MiMapGooglemaps & keyof MiMapGooglemapsAttributes as `attr:${K}`]?: MiMapGooglemapsAttributes[K] } & { [K in keyof MiMapGooglemaps & keyof MiMapGooglemapsAttributes as `prop:${K}`]?: MiMapGooglemaps[K] };
        "mi-map-mapbox": Omit<MiMapMapbox, keyof MiMapMapboxAttributes> & { [K in keyof MiMapMapbox & keyof MiMapMapboxAttributes]?: MiMapMapbox[K] } & { [K in keyof MiMapMapbox & keyof MiMapMapboxAttributes as `attr:${K}`]?: MiMapMapboxAttributes[K] } & { [K in keyof MiMapMapbox & keyof MiMapMapboxAttributes as `prop:${K}`]?: MiMapMapbox[K] };
        "mi-metric-card": Omit<MiMetricCard, keyof MiMetricCardAttributes> & { [K in keyof MiMetricCard & keyof MiMetricCardAttributes]?: MiMetricCard[K] } & { [K in keyof MiMetricCard & keyof MiMetricCardAttributes as `attr:${K}`]?: MiMetricCardAttributes[K] } & { [K in keyof MiMetricCard & keyof MiMetricCardAttributes as `prop:${K}`]?: MiMetricCard[K] };
        "mi-my-position": Omit<MiMyPosition, keyof MiMyPositionAttributes> & { [K in keyof MiMyPosition & keyof MiMyPositionAttributes]?: MiMyPosition[K] } & { [K in keyof MiMyPosition & keyof MiMyPositionAttributes as `attr:${K}`]?: MiMyPositionAttributes[K] } & { [K in keyof MiMyPosition & keyof MiMyPositionAttributes as `prop:${K}`]?: MiMyPosition[K] };
        "mi-notification": Omit<MiNotification, keyof MiNotificationAttributes> & { [K in keyof MiNotification & keyof MiNotificationAttributes]?: MiNotification[K] } & { [K in keyof MiNotification & keyof MiNotificationAttributes as `attr:${K}`]?: MiNotificationAttributes[K] } & { [K in keyof MiNotification & keyof MiNotificationAttributes as `prop:${K}`]?: MiNotification[K] };
        "mi-route-instructions": Omit<MiRouteInstructions, keyof MiRouteInstructionsAttributes> & { [K in keyof MiRouteInstructions & keyof MiRouteInstructionsAttributes]?: MiRouteInstructions[K] } & { [K in keyof MiRouteInstructions & keyof MiRouteInstructionsAttributes as `attr:${K}`]?: MiRouteInstructionsAttributes[K] } & { [K in keyof MiRouteInstructions & keyof MiRouteInstructionsAttributes as `prop:${K}`]?: MiRouteInstructions[K] };
        "mi-route-instructions-heading": Omit<MiRouteInstructionsHeading, keyof MiRouteInstructionsHeadingAttributes> & { [K in keyof MiRouteInstructionsHeading & keyof MiRouteInstructionsHeadingAttributes]?: MiRouteInstructionsHeading[K] } & { [K in keyof MiRouteInstructionsHeading & keyof MiRouteInstructionsHeadingAttributes as `attr:${K}`]?: MiRouteInstructionsHeadingAttributes[K] } & { [K in keyof MiRouteInstructionsHeading & keyof MiRouteInstructionsHeadingAttributes as `prop:${K}`]?: MiRouteInstructionsHeading[K] };
        "mi-route-instructions-maneuver": Omit<MiRouteInstructionsManeuver, keyof MiRouteInstructionsManeuverAttributes> & { [K in keyof MiRouteInstructionsManeuver & keyof MiRouteInstructionsManeuverAttributes]?: MiRouteInstructionsManeuver[K] } & { [K in keyof MiRouteInstructionsManeuver & keyof MiRouteInstructionsManeuverAttributes as `attr:${K}`]?: MiRouteInstructionsManeuverAttributes[K] } & { [K in keyof MiRouteInstructionsManeuver & keyof MiRouteInstructionsManeuverAttributes as `prop:${K}`]?: MiRouteInstructionsManeuver[K] };
        "mi-route-instructions-maneuver-legacy": Omit<MiRouteInstructionsManeuverLegacy, keyof MiRouteInstructionsManeuverLegacyAttributes> & { [K in keyof MiRouteInstructionsManeuverLegacy & keyof MiRouteInstructionsManeuverLegacyAttributes]?: MiRouteInstructionsManeuverLegacy[K] } & { [K in keyof MiRouteInstructionsManeuverLegacy & keyof MiRouteInstructionsManeuverLegacyAttributes as `attr:${K}`]?: MiRouteInstructionsManeuverLegacyAttributes[K] } & { [K in keyof MiRouteInstructionsManeuverLegacy & keyof MiRouteInstructionsManeuverLegacyAttributes as `prop:${K}`]?: MiRouteInstructionsManeuverLegacy[K] };
        "mi-route-instructions-step": Omit<MiRouteInstructionsStep, keyof MiRouteInstructionsStepAttributes> & { [K in keyof MiRouteInstructionsStep & keyof MiRouteInstructionsStepAttributes]?: MiRouteInstructionsStep[K] } & { [K in keyof MiRouteInstructionsStep & keyof MiRouteInstructionsStepAttributes as `attr:${K}`]?: MiRouteInstructionsStepAttributes[K] } & { [K in keyof MiRouteInstructionsStep & keyof MiRouteInstructionsStepAttributes as `prop:${K}`]?: MiRouteInstructionsStep[K] };
        "mi-route-instructions-step-legacy": Omit<MiRouteInstructionsStepLegacy, keyof MiRouteInstructionsStepLegacyAttributes> & { [K in keyof MiRouteInstructionsStepLegacy & keyof MiRouteInstructionsStepLegacyAttributes]?: MiRouteInstructionsStepLegacy[K] } & { [K in keyof MiRouteInstructionsStepLegacy & keyof MiRouteInstructionsStepLegacyAttributes as `attr:${K}`]?: MiRouteInstructionsStepLegacyAttributes[K] } & { [K in keyof MiRouteInstructionsStepLegacy & keyof MiRouteInstructionsStepLegacyAttributes as `prop:${K}`]?: MiRouteInstructionsStepLegacy[K] };
        "mi-scroll-buttons": Omit<MiScrollButtons, keyof MiScrollButtonsAttributes> & { [K in keyof MiScrollButtons & keyof MiScrollButtonsAttributes]?: MiScrollButtons[K] } & { [K in keyof MiScrollButtons & keyof MiScrollButtonsAttributes as `attr:${K}`]?: MiScrollButtonsAttributes[K] } & { [K in keyof MiScrollButtons & keyof MiScrollButtonsAttributes as `prop:${K}`]?: MiScrollButtons[K] };
        "mi-search": Omit<MiSearch, keyof MiSearchAttributes> & { [K in keyof MiSearch & keyof MiSearchAttributes]?: MiSearch[K] } & { [K in keyof MiSearch & keyof MiSearchAttributes as `attr:${K}`]?: MiSearchAttributes[K] } & { [K in keyof MiSearch & keyof MiSearchAttributes as `prop:${K}`]?: MiSearch[K] };
        "mi-share-sms": Omit<MiShareSms, keyof MiShareSmsAttributes> & { [K in keyof MiShareSms & keyof MiShareSmsAttributes]?: MiShareSms[K] } & { [K in keyof MiShareSms & keyof MiShareSmsAttributes as `attr:${K}`]?: MiShareSmsAttributes[K] } & { [K in keyof MiShareSms & keyof MiShareSmsAttributes as `prop:${K}`]?: MiShareSms[K] };
        "mi-spinner": Omit<MiSpinner, keyof MiSpinnerAttributes> & { [K in keyof MiSpinner & keyof MiSpinnerAttributes]?: MiSpinner[K] } & { [K in keyof MiSpinner & keyof MiSpinnerAttributes as `attr:${K}`]?: MiSpinnerAttributes[K] } & { [K in keyof MiSpinner & keyof MiSpinnerAttributes as `prop:${K}`]?: MiSpinner[K] };
        "mi-step-switcher": Omit<MiStepSwitcher, keyof MiStepSwitcherAttributes> & { [K in keyof MiStepSwitcher & keyof MiStepSwitcherAttributes]?: MiStepSwitcher[K] } & { [K in keyof MiStepSwitcher & keyof MiStepSwitcherAttributes as `attr:${K}`]?: MiStepSwitcherAttributes[K] } & { [K in keyof MiStepSwitcher & keyof MiStepSwitcherAttributes as `prop:${K}`]?: MiStepSwitcher[K] };
        "mi-tab": Omit<MiTab, keyof MiTabAttributes> & { [K in keyof MiTab & keyof MiTabAttributes]?: MiTab[K] } & { [K in keyof MiTab & keyof MiTabAttributes as `attr:${K}`]?: MiTabAttributes[K] } & { [K in keyof MiTab & keyof MiTabAttributes as `prop:${K}`]?: MiTab[K] };
        "mi-tab-panel": MiTabPanel;
        "mi-tabs": Omit<MiTabs, keyof MiTabsAttributes> & { [K in keyof MiTabs & keyof MiTabsAttributes]?: MiTabs[K] } & { [K in keyof MiTabs & keyof MiTabsAttributes as `attr:${K}`]?: MiTabsAttributes[K] } & { [K in keyof MiTabs & keyof MiTabsAttributes as `prop:${K}`]?: MiTabs[K] };
        "mi-time": Omit<MiTime, keyof MiTimeAttributes> & { [K in keyof MiTime & keyof MiTimeAttributes]?: MiTime[K] } & { [K in keyof MiTime & keyof MiTimeAttributes as `attr:${K}`]?: MiTimeAttributes[K] } & { [K in keyof MiTime & keyof MiTimeAttributes as `prop:${K}`]?: MiTime[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "combo-box-item": LocalJSX.IntrinsicElements["combo-box-item"] & JSXBase.HTMLAttributes<HTMLComboBoxItemElement>;
            "mi-card": LocalJSX.IntrinsicElements["mi-card"] & JSXBase.HTMLAttributes<HTMLMiCardElement>;
            "mi-chip": LocalJSX.IntrinsicElements["mi-chip"] & JSXBase.HTMLAttributes<HTMLMiChipElement>;
            "mi-column": LocalJSX.IntrinsicElements["mi-column"] & JSXBase.HTMLAttributes<HTMLMiColumnElement>;
            "mi-combo-box": LocalJSX.IntrinsicElements["mi-combo-box"] & JSXBase.HTMLAttributes<HTMLMiComboBoxElement>;
            "mi-data-table": LocalJSX.IntrinsicElements["mi-data-table"] & JSXBase.HTMLAttributes<HTMLMiDataTableElement>;
            "mi-distance": LocalJSX.IntrinsicElements["mi-distance"] & JSXBase.HTMLAttributes<HTMLMiDistanceElement>;
            "mi-dropdown": LocalJSX.IntrinsicElements["mi-dropdown"] & JSXBase.HTMLAttributes<HTMLMiDropdownElement>;
            "mi-dropdown-item": LocalJSX.IntrinsicElements["mi-dropdown-item"] & JSXBase.HTMLAttributes<HTMLMiDropdownItemElement>;
            "mi-floor-selector": LocalJSX.IntrinsicElements["mi-floor-selector"] & JSXBase.HTMLAttributes<HTMLMiFloorSelectorElement>;
            "mi-icon": LocalJSX.IntrinsicElements["mi-icon"] & JSXBase.HTMLAttributes<HTMLMiIconElement>;
            "mi-keyboard": LocalJSX.IntrinsicElements["mi-keyboard"] & JSXBase.HTMLAttributes<HTMLMiKeyboardElement>;
            "mi-list": LocalJSX.IntrinsicElements["mi-list"] & JSXBase.HTMLAttributes<HTMLMiListElement>;
            "mi-list-item-category": LocalJSX.IntrinsicElements["mi-list-item-category"] & JSXBase.HTMLAttributes<HTMLMiListItemCategoryElement>;
            "mi-list-item-location": LocalJSX.IntrinsicElements["mi-list-item-location"] & JSXBase.HTMLAttributes<HTMLMiListItemLocationElement>;
            "mi-location-booking": LocalJSX.IntrinsicElements["mi-location-booking"] & JSXBase.HTMLAttributes<HTMLMiLocationBookingElement>;
            "mi-location-info": LocalJSX.IntrinsicElements["mi-location-info"] & JSXBase.HTMLAttributes<HTMLMiLocationInfoElement>;
            "mi-map-googlemaps": LocalJSX.IntrinsicElements["mi-map-googlemaps"] & JSXBase.HTMLAttributes<HTMLMiMapGooglemapsElement>;
            "mi-map-mapbox": LocalJSX.IntrinsicElements["mi-map-mapbox"] & JSXBase.HTMLAttributes<HTMLMiMapMapboxElement>;
            "mi-metric-card": LocalJSX.IntrinsicElements["mi-metric-card"] & JSXBase.HTMLAttributes<HTMLMiMetricCardElement>;
            "mi-my-position": LocalJSX.IntrinsicElements["mi-my-position"] & JSXBase.HTMLAttributes<HTMLMiMyPositionElement>;
            "mi-notification": LocalJSX.IntrinsicElements["mi-notification"] & JSXBase.HTMLAttributes<HTMLMiNotificationElement>;
            "mi-route-instructions": LocalJSX.IntrinsicElements["mi-route-instructions"] & JSXBase.HTMLAttributes<HTMLMiRouteInstructionsElement>;
            "mi-route-instructions-heading": LocalJSX.IntrinsicElements["mi-route-instructions-heading"] & JSXBase.HTMLAttributes<HTMLMiRouteInstructionsHeadingElement>;
            "mi-route-instructions-maneuver": LocalJSX.IntrinsicElements["mi-route-instructions-maneuver"] & JSXBase.HTMLAttributes<HTMLMiRouteInstructionsManeuverElement>;
            "mi-route-instructions-maneuver-legacy": LocalJSX.IntrinsicElements["mi-route-instructions-maneuver-legacy"] & JSXBase.HTMLAttributes<HTMLMiRouteInstructionsManeuverLegacyElement>;
            "mi-route-instructions-step": LocalJSX.IntrinsicElements["mi-route-instructions-step"] & JSXBase.HTMLAttributes<HTMLMiRouteInstructionsStepElement>;
            "mi-route-instructions-step-legacy": LocalJSX.IntrinsicElements["mi-route-instructions-step-legacy"] & JSXBase.HTMLAttributes<HTMLMiRouteInstructionsStepLegacyElement>;
            "mi-scroll-buttons": LocalJSX.IntrinsicElements["mi-scroll-buttons"] & JSXBase.HTMLAttributes<HTMLMiScrollButtonsElement>;
            "mi-search": LocalJSX.IntrinsicElements["mi-search"] & JSXBase.HTMLAttributes<HTMLMiSearchElement>;
            "mi-share-sms": LocalJSX.IntrinsicElements["mi-share-sms"] & JSXBase.HTMLAttributes<HTMLMiShareSmsElement>;
            "mi-spinner": LocalJSX.IntrinsicElements["mi-spinner"] & JSXBase.HTMLAttributes<HTMLMiSpinnerElement>;
            "mi-step-switcher": LocalJSX.IntrinsicElements["mi-step-switcher"] & JSXBase.HTMLAttributes<HTMLMiStepSwitcherElement>;
            "mi-tab": LocalJSX.IntrinsicElements["mi-tab"] & JSXBase.HTMLAttributes<HTMLMiTabElement>;
            "mi-tab-panel": LocalJSX.IntrinsicElements["mi-tab-panel"] & JSXBase.HTMLAttributes<HTMLMiTabPanelElement>;
            "mi-tabs": LocalJSX.IntrinsicElements["mi-tabs"] & JSXBase.HTMLAttributes<HTMLMiTabsElement>;
            "mi-time": LocalJSX.IntrinsicElements["mi-time"] & JSXBase.HTMLAttributes<HTMLMiTimeElement>;
        }
    }
}
